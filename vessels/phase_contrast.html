<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ukat.vessels.phase_contrast API documentation</title>
<meta name="description" content="The velocity and flow calculations in this Phase Contrast class
are based on the scientific paper: …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ukat.vessels.phase_contrast</code></h1>
</header>
<section id="section-intro">
<p>The velocity and flow calculations in this Phase Contrast class
are based on the scientific paper:</p>
<p>"Phase-contrast magnetic resonance imaging to assess renal perfusion:
a systematic review and statement paper"</p>
<p>Giulia Villa, Steffen Ringgaard, Ingo Hermann, Rebecca Noble, Paolo Brambilla,
Dinah S. Khatir, Frank G. Zöllner, Susan T. Francis, Nicholas M. Selby,
Andrea Remuzzi, Anna Caroli</p>
<p>Magnetic Resonance Materials in Physics, Biology and Medicine (2020) 33:3-21
<a href="https://doi.org/10.1007/s10334-019-00772-0">https://doi.org/10.1007/s10334-019-00772-0</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The velocity and flow calculations in this Phase Contrast class
are based on the scientific paper:

&#34;Phase-contrast magnetic resonance imaging to assess renal perfusion:
a systematic review and statement paper&#34;

Giulia Villa, Steffen Ringgaard, Ingo Hermann, Rebecca Noble, Paolo Brambilla,
Dinah S. Khatir, Frank G. Zöllner, Susan T. Francis, Nicholas M. Selby,
Andrea Remuzzi, Anna Caroli

Magnetic Resonance Materials in Physics, Biology and Medicine (2020) 33:3-21
https://doi.org/10.1007/s10334-019-00772-0
&#34;&#34;&#34;

import os
import pandas as pd
import numpy as np
import nibabel as nib
import matplotlib.pyplot as plt
from tabulate import tabulate
from ukat.utils.tools import convert_to_pi_range


class PhaseContrast:
    &#34;&#34;&#34;
    Generates velocity and flow measurements of an MRI Phase Contrast Sequence.

    Attributes
    ----------
    velocity_array : np.ndarray
        The input velocity array masked.
    shape : tuple
        The shape of the velocity array.
    pixel_spacing : tuple
        The pixel spacing of the acquisition estimated from the affine.
    mask : np.ndarray
        A boolean mask of the voxels to fit.
    num_pixels : np.ndarray
        List containing the number of True values in the mask per phase.
    area : np.ndarray
        List containing the area (cm2) of the mask per phase.
    min_velocity : np.ndarray
        List containing the minimum velocity values (cm/s) per phase.
    mean_velocity : np.ndarray
        List containing the average velocity values (cm/s) per phase.
    max_velocity : np.ndarray
        List containing the maximum velocity values (cm/s) per phase.
    std_velocity : np.ndarray
        List containing the std dev of the velocity values (cm/s) per phase.
    rbf : np.ndarray
        List containing the Renal Blood Flow values (ml/min) per phase.
    mean_velocity_global : float
        Average velocity (cm/s) across the different phases.
    mean_rbf : float
        Average Renal Blood Flow (ml/min) across the different phases.
    resistive_index : float
        A prognostic marker in renal vascular diseases which range is [0, 1].
    &#34;&#34;&#34;

    def __init__(self, velocity_array, affine, mask):
        &#34;&#34;&#34;Initialise a PhaseContrast class instance.

        Parameters
        ----------
        velocity_array : np.ndarray
            A 3D array containing the velocity images of the phase contrast
            sequence, i.e. the dimensions of the array are [x, y, p], where p
            corresponds to the phase (or trigger delay).
        affine : np.ndarray
            A matrix giving the relationship between voxel coordinates and
            world coordinates.
        mask : np.ndarray
            A boolean mask of the voxels to fit. Should be the shape of
            the raw data.
        &#34;&#34;&#34;
        self.shape = velocity_array.shape
        self.affine = affine
        self.pixel_spacing = (np.linalg.norm(self.affine[:3, 1]),
                              np.linalg.norm(self.affine[:3, 0]))
        self.mask = np.where(mask, mask, np.nan)
        self.velocity_array = np.abs(velocity_array * self.mask)
        self.num_pixels = []
        self.area = []
        self.min_velocity = []
        self.mean_velocity = []
        self.max_velocity = []
        self.std_velocity = []
        self.rbf = []
        self.mean_velocity_global = 0
        self.mean_rbf = 0
        self.resistive_index = 0
        if len(self.shape) == 3:
            # Extract number pixels, area, velocity stats (min, mean, max, std)
            # and renal blood flow (RBF)
            self.num_pixels = np.count_nonzero(~np.isnan(self.velocity_array),
                                               axis=(0, 1))
            # area = (num_pixels * mm * mm * 0.01) = cm2
            self.area = (self.num_pixels * self.pixel_spacing[0] *
                         self.pixel_spacing[1] * 0.01)
            self.min_velocity = np.nanmin(self.velocity_array, axis=(0, 1))
            self.mean_velocity = np.nanmean(self.velocity_array, axis=(0, 1))
            self.max_velocity = np.nanmax(self.velocity_array, axis=(0, 1))
            self.std_velocity = np.nanstd(self.velocity_array, axis=(0, 1))
            # q = (60 * cm2 * cm/s) = ml/min
            self.rbf = 60 * np.array(self.area * self.mean_velocity)
            # Mean velocity global and mean flow
            self.mean_velocity_global = np.mean(self.mean_velocity)
            self.mean_rbf = np.mean(self.rbf)
            # Restrictive Index
            mean_velocity_systole = np.max(self.mean_velocity)
            mean_velocity_diastole = np.min(self.mean_velocity)
            self.resistive_index = ((mean_velocity_systole -
                                     mean_velocity_diastole) /
                                    mean_velocity_systole)
            # Convert any nan values to 0
            self.velocity_array = np.nan_to_num(self.velocity_array)
            self.mask = np.nan_to_num(self.mask)
        else:
            raise ValueError(&#39;The input velocity_array should be 3D.&#39;)

    def get_stats_table(self):
        &#34;&#34;&#34;
        Stores most of PhaseContrast class attributes into a pandas DataFrame.

        Returns
        ----------
        table : pandas.DataFrame
            Returns a table with the results/stats of each output per phase.
        &#34;&#34;&#34;
        stats = {&#34;RBF (ml/min)&#34;: self.rbf,
                 &#34;Area (cm2)&#34;: self.area,
                 &#34;Nr Pixels&#34;: self.num_pixels,
                 &#34;Mean Vel (cm/s)&#34;: self.mean_velocity,
                 &#34;Min Vel (cm/s)&#34;: self.min_velocity,
                 &#34;Max Vel (cm/s)&#34;: self.max_velocity,
                 &#34;StdDev Vel (cm/s)&#34;: self.std_velocity}
        table = pd.DataFrame(data=stats)
        return table

    def print_stats(self):
        &#34;&#34;&#34;
        Prints the table with the stats for each output per phase.
        &#34;&#34;&#34;
        stats_table = self.get_stats_table()
        print(tabulate(stats_table, headers=&#39;keys&#39;, tablefmt=&#39;github&#39;,
              floatfmt=&#39;.3f&#39;))

    def to_csv(self, path):
        &#34;&#34;&#34;
        Saves the stats_table into a csv file.

        Parameters
        ----------
        path : str
            Path to the desired csv file.
        &#34;&#34;&#34;
        stats_table = self.get_stats_table()
        stats_table.to_csv(path)

    def plot(self, stat=&#39;default&#39;, file_name=None):
        &#34;&#34;&#34;
        This method plots the output PhaseContrast stats per phase.

        Parameters
        ----------
        stat : str, optional
            Name of the output stat variable. This method plots mean velocity
            and the RBF by default.
        file_name : str, optional
            Path to the image file (*.jpg, *.png, etc.)
            in which the plot will be saved.
        &#34;&#34;&#34;
        if stat == &#39;default&#39;:
            fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 10))
            ax1.plot(self.mean_velocity, &#39;ro-&#39;)
            ax1.set_ylabel(&#39;Velocity (cm/sec)&#39;)
            ax1.set_xlabel(&#39;Phase&#39;)
            ax1.set_title(&#39;Average Velocity&#39;)
            ax2.plot(self.rbf, &#39;b-&#39;)
            ax2.set_ylabel(&#39;RBF (ml/min)&#39;)
            ax2.set_xlabel(&#39;Phase&#39;)
            ax2.set_title(&#39;Renal Artery Blood Flow&#39;)
        else:
            if stat == &#39;min_velocity&#39;:
                stat_variable = self.min_velocity
                y_label = &#39;Velocity (cm/sec)&#39;
                title = &#39;Minimum Velocity&#39;
            elif stat == &#39;mean_velocity&#39;:
                stat_variable = self.mean_velocity
                y_label = &#39;Velocity (cm/sec)&#39;
                title = &#39;Average Velocity&#39;
            elif stat == &#39;max_velocity&#39;:
                stat_variable = self.max_velocity
                y_label = &#39;Velocity (cm/sec)&#39;
                title = &#39;Maximum Velocity&#39;
            elif stat == &#39;std_velocity&#39;:
                stat_variable = self.std_velocity
                y_label = &#39;Velocity (cm/sec)&#39;
                title = &#39;Standard Deviation of the Velocity&#39;
            elif stat == &#39;rbf&#39;:
                stat_variable = self.rbf
                y_label = &#39;RBF (ml/min)&#39;
                title = &#39;Renal Artery Blood Flow&#39;
            elif stat == &#39;num_pixels&#39;:
                stat_variable = self.num_pixels
                y_label = &#39;# Pixels&#39;
                title = &#39;Number of Pixels in the Region Of Interest (ROI)&#39;
            elif stat == &#39;area&#39;:
                stat_variable = self.area
                y_label = &#39;Area ($cm^2$)&#39;
                title = &#39;Area of the Region Of Interest (ROI)&#39;
            else:
                raise ValueError(&#39;The stat provided is not valid.&#39;)
            fig, ax = plt.subplots(figsize=(10, 10))
            ax.plot(stat_variable, &#39;ro-&#39;)
            ax.set_ylabel(y_label)
            ax.set_xlabel(&#39;Phase&#39;)
            ax.set_title(title)
        # The following saves the plot(s) to file_name, if given.
        if file_name is not None:
            fig.savefig(file_name)

    def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;,
                 maps=&#39;all&#39;):
        &#34;&#34;&#34;Exports the velocity array and the renal artery mask to NIfTI.

        Parameters
        ----------
        output_directory : string, optional
            Path to the folder where the NIfTI files will be saved.
        base_file_name : string, optional
            Filename of the resulting NIfTI. This code appends the extension.
            Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
        maps : list or &#39;all&#39;, optional
            List of maps to save to NIfTI. This should either the string &#34;all&#34;
            or a list of maps from [&#34;phase_array&#34;, &#34;mask&#34;, &#34;velocity_array&#34;].
        &#34;&#34;&#34;
        os.makedirs(output_directory, exist_ok=True)
        base_path = os.path.join(output_directory, base_file_name)
        if maps == &#39;all&#39; or maps == [&#39;all&#39;]:
            maps = [&#34;velocity_array&#34;, &#34;mask&#34;]
        if isinstance(maps, list):
            for result in maps:
                if result == &#39;velocity_array&#39; or result == &#39;velocity array&#39;:
                    velocity_nifti = nib.Nifti1Image(self.velocity_array,
                                                     affine=self.affine)
                    nib.save(velocity_nifti, base_path +
                             &#39;_velocity_array.nii.gz&#39;)
                elif result == &#39;mask&#39;:
                    mask_nifti = nib.Nifti1Image(self.mask.astype(np.uint16),
                                                 affine=self.affine)
                    nib.save(mask_nifti, base_path + &#39;_mask.nii.gz&#39;)
        else:
            raise ValueError(&#39;No NIfTI file saved. The variable &#34;maps&#34; &#39;
                             &#39;should be &#34;all&#34; or a list of maps from &#39;
                             &#39;&#34;[&#34;velocity_array&#34;, &#34;mask&#34;]&#34;.&#39;)


def convert_to_velocity(pixel_array, velocity_encoding,
                        velocity_encode_scale=None):
    &#34;&#34;&#34;
    Calculate the velocity array from the given input image and
    velocity encoding. If a velocity encode scale is given then it is
    used to convert the pixel_value to radians.

    Parameters
    ----------
    pixel_array: np.ndarray
        A 3D array containing the phase images of the phase contrast sequence.
    velocity_encoding : float
        The value of the velocity encoding in cm/s.
    velocity_encode_scale : float, optional
        If given, this value is used to scale from image intensity to radians.

    Returns
    -------
    velocity_array: np.ndarray
        A 3D array containing the velocity images of the phase contrast
        sequence, i.e. the dimensions of the array are [x, y, p], where p
        corresponds to the phase (or trigger delay).
    &#34;&#34;&#34;
    if velocity_encode_scale is not None:
        pi_range_array = pixel_array / velocity_encode_scale
    else:
        pi_range_array = convert_to_pi_range(pixel_array)
    velocity_array = pi_range_array * velocity_encoding
    return velocity_array</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ukat.vessels.phase_contrast.convert_to_velocity"><code class="name flex">
<span>def <span class="ident">convert_to_velocity</span></span>(<span>pixel_array, velocity_encoding, velocity_encode_scale=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the velocity array from the given input image and
velocity encoding. If a velocity encode scale is given then it is
used to convert the pixel_value to radians.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pixel_array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A 3D array containing the phase images of the phase contrast sequence.</dd>
<dt><strong><code>velocity_encoding</code></strong> :&ensp;<code>float</code></dt>
<dd>The value of the velocity encoding in cm/s.</dd>
<dt><strong><code>velocity_encode_scale</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>If given, this value is used to scale from image intensity to radians.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>velocity_array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A 3D array containing the velocity images of the phase contrast
sequence, i.e. the dimensions of the array are [x, y, p], where p
corresponds to the phase (or trigger delay).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_to_velocity(pixel_array, velocity_encoding,
                        velocity_encode_scale=None):
    &#34;&#34;&#34;
    Calculate the velocity array from the given input image and
    velocity encoding. If a velocity encode scale is given then it is
    used to convert the pixel_value to radians.

    Parameters
    ----------
    pixel_array: np.ndarray
        A 3D array containing the phase images of the phase contrast sequence.
    velocity_encoding : float
        The value of the velocity encoding in cm/s.
    velocity_encode_scale : float, optional
        If given, this value is used to scale from image intensity to radians.

    Returns
    -------
    velocity_array: np.ndarray
        A 3D array containing the velocity images of the phase contrast
        sequence, i.e. the dimensions of the array are [x, y, p], where p
        corresponds to the phase (or trigger delay).
    &#34;&#34;&#34;
    if velocity_encode_scale is not None:
        pi_range_array = pixel_array / velocity_encode_scale
    else:
        pi_range_array = convert_to_pi_range(pixel_array)
    velocity_array = pi_range_array * velocity_encoding
    return velocity_array</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ukat.vessels.phase_contrast.PhaseContrast"><code class="flex name class">
<span>class <span class="ident">PhaseContrast</span></span>
<span>(</span><span>velocity_array, affine, mask)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates velocity and flow measurements of an MRI Phase Contrast Sequence.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>velocity_array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The input velocity array masked.</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The shape of the velocity array.</dd>
<dt><strong><code>pixel_spacing</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The pixel spacing of the acquisition estimated from the affine.</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A boolean mask of the voxels to fit.</dd>
<dt><strong><code>num_pixels</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>List containing the number of True values in the mask per phase.</dd>
<dt><strong><code>area</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>List containing the area (cm2) of the mask per phase.</dd>
<dt><strong><code>min_velocity</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>List containing the minimum velocity values (cm/s) per phase.</dd>
<dt><strong><code>mean_velocity</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>List containing the average velocity values (cm/s) per phase.</dd>
<dt><strong><code>max_velocity</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>List containing the maximum velocity values (cm/s) per phase.</dd>
<dt><strong><code>std_velocity</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>List containing the std dev of the velocity values (cm/s) per phase.</dd>
<dt><strong><code>rbf</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>List containing the Renal Blood Flow values (ml/min) per phase.</dd>
<dt><strong><code>mean_velocity_global</code></strong> :&ensp;<code>float</code></dt>
<dd>Average velocity (cm/s) across the different phases.</dd>
<dt><strong><code>mean_rbf</code></strong> :&ensp;<code>float</code></dt>
<dd>Average Renal Blood Flow (ml/min) across the different phases.</dd>
<dt><strong><code>resistive_index</code></strong> :&ensp;<code>float</code></dt>
<dd>A prognostic marker in renal vascular diseases which range is [0, 1].</dd>
</dl>
<p>Initialise a PhaseContrast class instance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>velocity_array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A 3D array containing the velocity images of the phase contrast
sequence, i.e. the dimensions of the array are [x, y, p], where p
corresponds to the phase (or trigger delay).</dd>
<dt><strong><code>affine</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A matrix giving the relationship between voxel coordinates and
world coordinates.</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A boolean mask of the voxels to fit. Should be the shape of
the raw data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PhaseContrast:
    &#34;&#34;&#34;
    Generates velocity and flow measurements of an MRI Phase Contrast Sequence.

    Attributes
    ----------
    velocity_array : np.ndarray
        The input velocity array masked.
    shape : tuple
        The shape of the velocity array.
    pixel_spacing : tuple
        The pixel spacing of the acquisition estimated from the affine.
    mask : np.ndarray
        A boolean mask of the voxels to fit.
    num_pixels : np.ndarray
        List containing the number of True values in the mask per phase.
    area : np.ndarray
        List containing the area (cm2) of the mask per phase.
    min_velocity : np.ndarray
        List containing the minimum velocity values (cm/s) per phase.
    mean_velocity : np.ndarray
        List containing the average velocity values (cm/s) per phase.
    max_velocity : np.ndarray
        List containing the maximum velocity values (cm/s) per phase.
    std_velocity : np.ndarray
        List containing the std dev of the velocity values (cm/s) per phase.
    rbf : np.ndarray
        List containing the Renal Blood Flow values (ml/min) per phase.
    mean_velocity_global : float
        Average velocity (cm/s) across the different phases.
    mean_rbf : float
        Average Renal Blood Flow (ml/min) across the different phases.
    resistive_index : float
        A prognostic marker in renal vascular diseases which range is [0, 1].
    &#34;&#34;&#34;

    def __init__(self, velocity_array, affine, mask):
        &#34;&#34;&#34;Initialise a PhaseContrast class instance.

        Parameters
        ----------
        velocity_array : np.ndarray
            A 3D array containing the velocity images of the phase contrast
            sequence, i.e. the dimensions of the array are [x, y, p], where p
            corresponds to the phase (or trigger delay).
        affine : np.ndarray
            A matrix giving the relationship between voxel coordinates and
            world coordinates.
        mask : np.ndarray
            A boolean mask of the voxels to fit. Should be the shape of
            the raw data.
        &#34;&#34;&#34;
        self.shape = velocity_array.shape
        self.affine = affine
        self.pixel_spacing = (np.linalg.norm(self.affine[:3, 1]),
                              np.linalg.norm(self.affine[:3, 0]))
        self.mask = np.where(mask, mask, np.nan)
        self.velocity_array = np.abs(velocity_array * self.mask)
        self.num_pixels = []
        self.area = []
        self.min_velocity = []
        self.mean_velocity = []
        self.max_velocity = []
        self.std_velocity = []
        self.rbf = []
        self.mean_velocity_global = 0
        self.mean_rbf = 0
        self.resistive_index = 0
        if len(self.shape) == 3:
            # Extract number pixels, area, velocity stats (min, mean, max, std)
            # and renal blood flow (RBF)
            self.num_pixels = np.count_nonzero(~np.isnan(self.velocity_array),
                                               axis=(0, 1))
            # area = (num_pixels * mm * mm * 0.01) = cm2
            self.area = (self.num_pixels * self.pixel_spacing[0] *
                         self.pixel_spacing[1] * 0.01)
            self.min_velocity = np.nanmin(self.velocity_array, axis=(0, 1))
            self.mean_velocity = np.nanmean(self.velocity_array, axis=(0, 1))
            self.max_velocity = np.nanmax(self.velocity_array, axis=(0, 1))
            self.std_velocity = np.nanstd(self.velocity_array, axis=(0, 1))
            # q = (60 * cm2 * cm/s) = ml/min
            self.rbf = 60 * np.array(self.area * self.mean_velocity)
            # Mean velocity global and mean flow
            self.mean_velocity_global = np.mean(self.mean_velocity)
            self.mean_rbf = np.mean(self.rbf)
            # Restrictive Index
            mean_velocity_systole = np.max(self.mean_velocity)
            mean_velocity_diastole = np.min(self.mean_velocity)
            self.resistive_index = ((mean_velocity_systole -
                                     mean_velocity_diastole) /
                                    mean_velocity_systole)
            # Convert any nan values to 0
            self.velocity_array = np.nan_to_num(self.velocity_array)
            self.mask = np.nan_to_num(self.mask)
        else:
            raise ValueError(&#39;The input velocity_array should be 3D.&#39;)

    def get_stats_table(self):
        &#34;&#34;&#34;
        Stores most of PhaseContrast class attributes into a pandas DataFrame.

        Returns
        ----------
        table : pandas.DataFrame
            Returns a table with the results/stats of each output per phase.
        &#34;&#34;&#34;
        stats = {&#34;RBF (ml/min)&#34;: self.rbf,
                 &#34;Area (cm2)&#34;: self.area,
                 &#34;Nr Pixels&#34;: self.num_pixels,
                 &#34;Mean Vel (cm/s)&#34;: self.mean_velocity,
                 &#34;Min Vel (cm/s)&#34;: self.min_velocity,
                 &#34;Max Vel (cm/s)&#34;: self.max_velocity,
                 &#34;StdDev Vel (cm/s)&#34;: self.std_velocity}
        table = pd.DataFrame(data=stats)
        return table

    def print_stats(self):
        &#34;&#34;&#34;
        Prints the table with the stats for each output per phase.
        &#34;&#34;&#34;
        stats_table = self.get_stats_table()
        print(tabulate(stats_table, headers=&#39;keys&#39;, tablefmt=&#39;github&#39;,
              floatfmt=&#39;.3f&#39;))

    def to_csv(self, path):
        &#34;&#34;&#34;
        Saves the stats_table into a csv file.

        Parameters
        ----------
        path : str
            Path to the desired csv file.
        &#34;&#34;&#34;
        stats_table = self.get_stats_table()
        stats_table.to_csv(path)

    def plot(self, stat=&#39;default&#39;, file_name=None):
        &#34;&#34;&#34;
        This method plots the output PhaseContrast stats per phase.

        Parameters
        ----------
        stat : str, optional
            Name of the output stat variable. This method plots mean velocity
            and the RBF by default.
        file_name : str, optional
            Path to the image file (*.jpg, *.png, etc.)
            in which the plot will be saved.
        &#34;&#34;&#34;
        if stat == &#39;default&#39;:
            fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 10))
            ax1.plot(self.mean_velocity, &#39;ro-&#39;)
            ax1.set_ylabel(&#39;Velocity (cm/sec)&#39;)
            ax1.set_xlabel(&#39;Phase&#39;)
            ax1.set_title(&#39;Average Velocity&#39;)
            ax2.plot(self.rbf, &#39;b-&#39;)
            ax2.set_ylabel(&#39;RBF (ml/min)&#39;)
            ax2.set_xlabel(&#39;Phase&#39;)
            ax2.set_title(&#39;Renal Artery Blood Flow&#39;)
        else:
            if stat == &#39;min_velocity&#39;:
                stat_variable = self.min_velocity
                y_label = &#39;Velocity (cm/sec)&#39;
                title = &#39;Minimum Velocity&#39;
            elif stat == &#39;mean_velocity&#39;:
                stat_variable = self.mean_velocity
                y_label = &#39;Velocity (cm/sec)&#39;
                title = &#39;Average Velocity&#39;
            elif stat == &#39;max_velocity&#39;:
                stat_variable = self.max_velocity
                y_label = &#39;Velocity (cm/sec)&#39;
                title = &#39;Maximum Velocity&#39;
            elif stat == &#39;std_velocity&#39;:
                stat_variable = self.std_velocity
                y_label = &#39;Velocity (cm/sec)&#39;
                title = &#39;Standard Deviation of the Velocity&#39;
            elif stat == &#39;rbf&#39;:
                stat_variable = self.rbf
                y_label = &#39;RBF (ml/min)&#39;
                title = &#39;Renal Artery Blood Flow&#39;
            elif stat == &#39;num_pixels&#39;:
                stat_variable = self.num_pixels
                y_label = &#39;# Pixels&#39;
                title = &#39;Number of Pixels in the Region Of Interest (ROI)&#39;
            elif stat == &#39;area&#39;:
                stat_variable = self.area
                y_label = &#39;Area ($cm^2$)&#39;
                title = &#39;Area of the Region Of Interest (ROI)&#39;
            else:
                raise ValueError(&#39;The stat provided is not valid.&#39;)
            fig, ax = plt.subplots(figsize=(10, 10))
            ax.plot(stat_variable, &#39;ro-&#39;)
            ax.set_ylabel(y_label)
            ax.set_xlabel(&#39;Phase&#39;)
            ax.set_title(title)
        # The following saves the plot(s) to file_name, if given.
        if file_name is not None:
            fig.savefig(file_name)

    def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;,
                 maps=&#39;all&#39;):
        &#34;&#34;&#34;Exports the velocity array and the renal artery mask to NIfTI.

        Parameters
        ----------
        output_directory : string, optional
            Path to the folder where the NIfTI files will be saved.
        base_file_name : string, optional
            Filename of the resulting NIfTI. This code appends the extension.
            Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
        maps : list or &#39;all&#39;, optional
            List of maps to save to NIfTI. This should either the string &#34;all&#34;
            or a list of maps from [&#34;phase_array&#34;, &#34;mask&#34;, &#34;velocity_array&#34;].
        &#34;&#34;&#34;
        os.makedirs(output_directory, exist_ok=True)
        base_path = os.path.join(output_directory, base_file_name)
        if maps == &#39;all&#39; or maps == [&#39;all&#39;]:
            maps = [&#34;velocity_array&#34;, &#34;mask&#34;]
        if isinstance(maps, list):
            for result in maps:
                if result == &#39;velocity_array&#39; or result == &#39;velocity array&#39;:
                    velocity_nifti = nib.Nifti1Image(self.velocity_array,
                                                     affine=self.affine)
                    nib.save(velocity_nifti, base_path +
                             &#39;_velocity_array.nii.gz&#39;)
                elif result == &#39;mask&#39;:
                    mask_nifti = nib.Nifti1Image(self.mask.astype(np.uint16),
                                                 affine=self.affine)
                    nib.save(mask_nifti, base_path + &#39;_mask.nii.gz&#39;)
        else:
            raise ValueError(&#39;No NIfTI file saved. The variable &#34;maps&#34; &#39;
                             &#39;should be &#34;all&#34; or a list of maps from &#39;
                             &#39;&#34;[&#34;velocity_array&#34;, &#34;mask&#34;]&#34;.&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ukat.vessels.phase_contrast.PhaseContrast.get_stats_table"><code class="name flex">
<span>def <span class="ident">get_stats_table</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores most of PhaseContrast class attributes into a pandas DataFrame.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Returns a table with the results/stats of each output per phase.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stats_table(self):
    &#34;&#34;&#34;
    Stores most of PhaseContrast class attributes into a pandas DataFrame.

    Returns
    ----------
    table : pandas.DataFrame
        Returns a table with the results/stats of each output per phase.
    &#34;&#34;&#34;
    stats = {&#34;RBF (ml/min)&#34;: self.rbf,
             &#34;Area (cm2)&#34;: self.area,
             &#34;Nr Pixels&#34;: self.num_pixels,
             &#34;Mean Vel (cm/s)&#34;: self.mean_velocity,
             &#34;Min Vel (cm/s)&#34;: self.min_velocity,
             &#34;Max Vel (cm/s)&#34;: self.max_velocity,
             &#34;StdDev Vel (cm/s)&#34;: self.std_velocity}
    table = pd.DataFrame(data=stats)
    return table</code></pre>
</details>
</dd>
<dt id="ukat.vessels.phase_contrast.PhaseContrast.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, stat='default', file_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This method plots the output PhaseContrast stats per phase.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stat</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the output stat variable. This method plots mean velocity
and the RBF by default.</dd>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Path to the image file (<em>.jpg, </em>.png, etc.)
in which the plot will be saved.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, stat=&#39;default&#39;, file_name=None):
    &#34;&#34;&#34;
    This method plots the output PhaseContrast stats per phase.

    Parameters
    ----------
    stat : str, optional
        Name of the output stat variable. This method plots mean velocity
        and the RBF by default.
    file_name : str, optional
        Path to the image file (*.jpg, *.png, etc.)
        in which the plot will be saved.
    &#34;&#34;&#34;
    if stat == &#39;default&#39;:
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 10))
        ax1.plot(self.mean_velocity, &#39;ro-&#39;)
        ax1.set_ylabel(&#39;Velocity (cm/sec)&#39;)
        ax1.set_xlabel(&#39;Phase&#39;)
        ax1.set_title(&#39;Average Velocity&#39;)
        ax2.plot(self.rbf, &#39;b-&#39;)
        ax2.set_ylabel(&#39;RBF (ml/min)&#39;)
        ax2.set_xlabel(&#39;Phase&#39;)
        ax2.set_title(&#39;Renal Artery Blood Flow&#39;)
    else:
        if stat == &#39;min_velocity&#39;:
            stat_variable = self.min_velocity
            y_label = &#39;Velocity (cm/sec)&#39;
            title = &#39;Minimum Velocity&#39;
        elif stat == &#39;mean_velocity&#39;:
            stat_variable = self.mean_velocity
            y_label = &#39;Velocity (cm/sec)&#39;
            title = &#39;Average Velocity&#39;
        elif stat == &#39;max_velocity&#39;:
            stat_variable = self.max_velocity
            y_label = &#39;Velocity (cm/sec)&#39;
            title = &#39;Maximum Velocity&#39;
        elif stat == &#39;std_velocity&#39;:
            stat_variable = self.std_velocity
            y_label = &#39;Velocity (cm/sec)&#39;
            title = &#39;Standard Deviation of the Velocity&#39;
        elif stat == &#39;rbf&#39;:
            stat_variable = self.rbf
            y_label = &#39;RBF (ml/min)&#39;
            title = &#39;Renal Artery Blood Flow&#39;
        elif stat == &#39;num_pixels&#39;:
            stat_variable = self.num_pixels
            y_label = &#39;# Pixels&#39;
            title = &#39;Number of Pixels in the Region Of Interest (ROI)&#39;
        elif stat == &#39;area&#39;:
            stat_variable = self.area
            y_label = &#39;Area ($cm^2$)&#39;
            title = &#39;Area of the Region Of Interest (ROI)&#39;
        else:
            raise ValueError(&#39;The stat provided is not valid.&#39;)
        fig, ax = plt.subplots(figsize=(10, 10))
        ax.plot(stat_variable, &#39;ro-&#39;)
        ax.set_ylabel(y_label)
        ax.set_xlabel(&#39;Phase&#39;)
        ax.set_title(title)
    # The following saves the plot(s) to file_name, if given.
    if file_name is not None:
        fig.savefig(file_name)</code></pre>
</details>
</dd>
<dt id="ukat.vessels.phase_contrast.PhaseContrast.print_stats"><code class="name flex">
<span>def <span class="ident">print_stats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the table with the stats for each output per phase.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_stats(self):
    &#34;&#34;&#34;
    Prints the table with the stats for each output per phase.
    &#34;&#34;&#34;
    stats_table = self.get_stats_table()
    print(tabulate(stats_table, headers=&#39;keys&#39;, tablefmt=&#39;github&#39;,
          floatfmt=&#39;.3f&#39;))</code></pre>
</details>
</dd>
<dt id="ukat.vessels.phase_contrast.PhaseContrast.to_csv"><code class="name flex">
<span>def <span class="ident">to_csv</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the stats_table into a csv file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the desired csv file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_csv(self, path):
    &#34;&#34;&#34;
    Saves the stats_table into a csv file.

    Parameters
    ----------
    path : str
        Path to the desired csv file.
    &#34;&#34;&#34;
    stats_table = self.get_stats_table()
    stats_table.to_csv(path)</code></pre>
</details>
</dd>
<dt id="ukat.vessels.phase_contrast.PhaseContrast.to_nifti"><code class="name flex">
<span>def <span class="ident">to_nifti</span></span>(<span>self, output_directory='/home/runner/work/ukat/ukat', base_file_name='Output', maps='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Exports the velocity array and the renal artery mask to NIfTI.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>output_directory</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Path to the folder where the NIfTI files will be saved.</dd>
<dt><strong><code>base_file_name</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Filename of the resulting NIfTI. This code appends the extension.
Eg., base_file_name = 'Output' will result in 'Output.nii.gz'.</dd>
<dt><strong><code>maps</code></strong> :&ensp;<code>list</code> or <code>'all'</code>, optional</dt>
<dd>List of maps to save to NIfTI. This should either the string "all"
or a list of maps from ["phase_array", "mask", "velocity_array"].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;,
             maps=&#39;all&#39;):
    &#34;&#34;&#34;Exports the velocity array and the renal artery mask to NIfTI.

    Parameters
    ----------
    output_directory : string, optional
        Path to the folder where the NIfTI files will be saved.
    base_file_name : string, optional
        Filename of the resulting NIfTI. This code appends the extension.
        Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
    maps : list or &#39;all&#39;, optional
        List of maps to save to NIfTI. This should either the string &#34;all&#34;
        or a list of maps from [&#34;phase_array&#34;, &#34;mask&#34;, &#34;velocity_array&#34;].
    &#34;&#34;&#34;
    os.makedirs(output_directory, exist_ok=True)
    base_path = os.path.join(output_directory, base_file_name)
    if maps == &#39;all&#39; or maps == [&#39;all&#39;]:
        maps = [&#34;velocity_array&#34;, &#34;mask&#34;]
    if isinstance(maps, list):
        for result in maps:
            if result == &#39;velocity_array&#39; or result == &#39;velocity array&#39;:
                velocity_nifti = nib.Nifti1Image(self.velocity_array,
                                                 affine=self.affine)
                nib.save(velocity_nifti, base_path +
                         &#39;_velocity_array.nii.gz&#39;)
            elif result == &#39;mask&#39;:
                mask_nifti = nib.Nifti1Image(self.mask.astype(np.uint16),
                                             affine=self.affine)
                nib.save(mask_nifti, base_path + &#39;_mask.nii.gz&#39;)
    else:
        raise ValueError(&#39;No NIfTI file saved. The variable &#34;maps&#34; &#39;
                         &#39;should be &#34;all&#34; or a list of maps from &#39;
                         &#39;&#34;[&#34;velocity_array&#34;, &#34;mask&#34;]&#34;.&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ukat.vessels" href="index.html">ukat.vessels</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ukat.vessels.phase_contrast.convert_to_velocity" href="#ukat.vessels.phase_contrast.convert_to_velocity">convert_to_velocity</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ukat.vessels.phase_contrast.PhaseContrast" href="#ukat.vessels.phase_contrast.PhaseContrast">PhaseContrast</a></code></h4>
<ul class="">
<li><code><a title="ukat.vessels.phase_contrast.PhaseContrast.get_stats_table" href="#ukat.vessels.phase_contrast.PhaseContrast.get_stats_table">get_stats_table</a></code></li>
<li><code><a title="ukat.vessels.phase_contrast.PhaseContrast.plot" href="#ukat.vessels.phase_contrast.PhaseContrast.plot">plot</a></code></li>
<li><code><a title="ukat.vessels.phase_contrast.PhaseContrast.print_stats" href="#ukat.vessels.phase_contrast.PhaseContrast.print_stats">print_stats</a></code></li>
<li><code><a title="ukat.vessels.phase_contrast.PhaseContrast.to_csv" href="#ukat.vessels.phase_contrast.PhaseContrast.to_csv">to_csv</a></code></li>
<li><code><a title="ukat.vessels.phase_contrast.PhaseContrast.to_nifti" href="#ukat.vessels.phase_contrast.PhaseContrast.to_nifti">to_nifti</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>