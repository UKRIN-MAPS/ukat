<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ukat.mapping.t2_stimfit API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ukat.mapping.t2_stimfit</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import warnings

import nibabel as nib
import numpy as np
from numba import jit
from pathos.pools import ProcessPool
from scipy import optimize
from sklearn.metrics import r2_score
from tqdm import tqdm

from .resources.t2_stimfit import rf_pulses
from ukat.mapping.t2 import two_param_eq
from ukat.utils.tools import rescale_b1_map


class StimFitModel:
    def __init__(self, mode=&#39;non_selective&#39;, n_comp=1, ukrin_vendor=None):
        &#34;&#34;&#34;
        A class to set up the T2 StimFit model.

        This model generates an optimisation dictionary (`opt`) containing the
        model parameters and fitting options.

        Parameters
        ----------
        mode : {&#39;non_selective&#39;, &#39;selective&#39;}, optional
            Default &#39;non_selective&#39;
            Choose whether the refocusing pulses are selective on
            non-selective.
        n_comp : {1, 2, 3}, optional
            Default 1
            The number of components to fit e.g. if n_comp=2, the model will
            estimate two T2 values, two M0 values and one B1 value per voxel.
        ukrin_vendor : {None, &#39;ge&#39;, &#39;philips&#39;, &#39;siemens&#39;}, optional
            Default None
            The vendor of the MRI scanner used to acquire the data if the UKRIN
            protocol was used. Specifying a vendor at this stage overrides
            the relevant parameters in the model with those from the UKRIN
            protocol. If no vendor is specified, the default parameters are
            used but can be manually updated after instantiation.

        Key Parameters in Options Dictionary
        ----------
        mode : {&#39;non_selective&#39;, &#39;selective&#39;}
            Choose whether the refocusing pulses are slice selective or
            non-selective.
        esp : float
            The echo spacing in seconds.
        etl : int
            The echo train length.
        T1 : float
            The approximate T1 value in seconds.
        Dz : list
            The start and end position of each slice in cm.
        Nz : int
            The number of positions along the slice profile to simulate signal
            decay for.
        Nrf : int
            The number of resampled points in the RF waveform.
        RFe : dict
            The excitation pulse parameters, outlined below.
        RFr : dict
            The refocusing pulse parameters, outlined below.
        lsq : dict
            The least squares fitting parameters, outlined below.

        Key Parameters in RFe Dictionary
        ----------
        RF : np.ndarray
            The excitation pulse shape.
        G : float
            The amplitude of the excitation pulse in Gauss/cm.
        tau : float
            The excitation pulse duration in seconds.
        phase : float
            The relative phase of the excitation pulse in degrees (0 in CPMG).
        angle : float
            The flip angle of the excitation pulse in degrees (typically 90).
        ref : float
            The rephasing gradient fraction, times two. Near unity for
            excitation.
        alpha : list, optional
            The actual tip angle distribution across the slice (degrees). If
            not specified, the tip angle distribution is calculated.

        Key Parameters in RFr Dictionary
        ----------
        RF : np.ndarray
            The refocusing pulse shape.
        G : float
            The amplitude of the refocusing pulse in Gauss/cm.
        tau : float
            The refocusing pulse duration in seconds.
        phase : float
            The relative phase of the refocusing pulse in degrees (90 in CPMG).
        angle : float
            The flip angle of the refocusing pulse in degrees (typically 180).
        ref : float
            The rephasing gradient fraction, times two. Typically, 0 for
            refocusing.
        alpha : list, optional
            The actual refocusing angle distribution across the slice
            (degrees). If not specified, the tip angle distribution is
            calculated.

        Key Parameters in lsq Dictionary
        ----------
        Ncomp : int
            The number of components to fit.
        X0 : list
            The initial guess for the fitting parameters in the order
            [[T2_comp, M0_comp] * Ncomp, B1].
        XL : list
            The lower bounds for the fitting parameters in the order
            [[T2_comp, M0_comp] * Ncomp, B1].
        XU : list
            The upper bounds for the fitting parameters in the order
            [[T2_comp, M0_comp] * Ncomp, B1].
        xtol : float
            Tolerance for termination by the change of the independent
            variables.
        ftol : float
            Tolerance for termination by the change of the cost function.
        &#34;&#34;&#34;
        if mode != &#39;non_selective&#39; and mode != &#39;selective&#39;:
            raise ValueError(f&#39;mode must be either &#34;non_selective&#34; or &#39;
                             f&#39;&#34;selective&#34;. You specified {mode}.&#39;)
        self.mode = mode
        if n_comp not in [1, 2, 3]:
            raise ValueError(f&#39;n_comp must be either 1, 2 or 3. You specified &#39;
                             f&#39;{n_comp}.&#39;)
        self.n_comp = n_comp
        if ukrin_vendor not in [&#39;ge&#39;, &#39;philips&#39;, &#39;siemens&#39;]:
            warnings.warn(&#39;ukrin_vendor was not specified. Using default &#39;
                          &#39;pulse sequence parameters.&#39;)
        self.opt = dict()
        self.opt[&#39;mode&#39;] = self.mode
        self.opt[&#39;esp&#39;] = 10e-3
        self.opt[&#39;etl&#39;] = 20
        self.opt[&#39;T1&#39;] = 3

        self.opt[&#39;RFe&#39;] = dict()
        self.opt[&#39;RFr&#39;] = dict()
        if self.mode == &#39;selective&#39;:
            self.opt[&#39;Dz&#39;] = [-0.5, 0.5]
            self.opt[&#39;Nz&#39;] = 51
            self.opt[&#39;Nrf&#39;] = 64
            self.opt[&#39;RFe&#39;] = {&#39;RF&#39;: [],
                               &#39;tau&#39;: 2e-3,
                               &#39;G&#39;: 0.5,
                               &#39;phase&#39;: 0,
                               &#39;ref&#39;: 1,
                               &#39;alpha&#39;: [],
                               &#39;angle&#39;: 90}
            self.opt[&#39;RFr&#39;] = {&#39;RF&#39;: [],
                               &#39;tau&#39;: 2e-3,
                               &#39;G&#39;: 0.5,
                               &#39;phase&#39;: 90,
                               &#39;ref&#39;: 0,
                               &#39;alpha&#39;: [],
                               &#39;angle&#39;: 180,
                               &#39;FA_array&#39;: np.ones(self.opt[&#39;etl&#39;])}
        else:
            self.opt[&#39;RFe&#39;] = {&#39;angle&#39;: 90}
            self.opt[&#39;RFr&#39;] = {&#39;angle&#39;: 180,
                               &#39;FA_array&#39;: np.ones(self.opt[&#39;etl&#39;])}
        # Curve fitting parameters
        self.opt[&#39;lsq&#39;] = {&#39;Ncomp&#39;: n_comp,
                           &#39;xtol&#39;: 5e-4,
                           &#39;ftol&#39;: 1e-9}
        if self.opt[&#39;lsq&#39;][&#39;Ncomp&#39;] == 1:
            # [T2(sec), amp, B1]
            self.opt[&#39;lsq&#39;][&#39;X0&#39;] = [0.06, 0.1, 1]
            self.opt[&#39;lsq&#39;][&#39;XU&#39;] = [3, 1e+3, 1.8]
            self.opt[&#39;lsq&#39;][&#39;XL&#39;] = [0.015, 0, 0.2]
        elif self.opt[&#39;lsq&#39;][&#39;Ncomp&#39;] == 2:
            # [T2, amp, T2, amp, B1]
            self.opt[&#39;lsq&#39;][&#39;X0&#39;] = [0.02, 0.1, 0.331, 0.1, 1]
            self.opt[&#39;lsq&#39;][&#39;XU&#39;] = [0.25, 1e+3, 3, 1e+3, 1.8]
            self.opt[&#39;lsq&#39;][&#39;XL&#39;] = [0.015, 0, 0.25, 0, 0.2]
        elif self.opt[&#39;lsq&#39;][&#39;Ncomp&#39;] == 3:
            # [T2, amp, T2, amp, T2, amp, B1]
            self.opt[&#39;lsq&#39;][&#39;X0&#39;] = [0.02, 0.1, 0.036, 0.1, 0.131, 0.1, 1]
            self.opt[&#39;lsq&#39;][&#39;XU&#39;] = [0.035, 1e+3, 0.13, 1e3, 3, 1e+3, 1.8]
            self.opt[&#39;lsq&#39;][&#39;XL&#39;] = [0.015, 0, 0.035, 0, 0.13, 0, 0.2]

        if ukrin_vendor is not None:
            self._set_ukrin_vendor(ukrin_vendor)
            if self.mode == &#39;selective&#39;:
                self.opt[&#39;RFe&#39;] = self._set_rf(self.opt[&#39;RFe&#39;])
                self.opt[&#39;RFr&#39;] = self._set_rf(self.opt[&#39;RFr&#39;])

    def get_opt(self):
        return self.opt

    def get_lsq(self):
        return self.opt[&#39;lsq&#39;]

    def get_rfe(self):
        return self.opt[&#39;RFe&#39;]

    def get_rfr(self):
        return self.opt[&#39;RFr&#39;]

    def _set_ukrin_vendor(self, vendor):
        self.vendor = vendor
        self.opt[&#39;T1&#39;] = 1.5
        self.opt[&#39;esp&#39;] = 0.0129
        self.opt[&#39;etl&#39;] = 10
        self.opt[&#39;te&#39;] = (np.arange(self.opt[&#39;etl&#39;]) + 1) * self.opt[&#39;esp&#39;]
        self.opt[&#39;RFr&#39;][&#39;FA_array&#39;] = np.ones(self.opt[&#39;etl&#39;])
        if self.vendor == &#39;ge&#39;:
            self.opt[&#39;RFe&#39;][&#39;tau&#39;] = 2000 / 1e6  # Duration
            self.opt[&#39;RFe&#39;][&#39;G&#39;] = 0.751599  # Amplitude
            self.opt[&#39;RFr&#39;][&#39;tau&#39;] = 3136 / 1e6
            self.opt[&#39;RFr&#39;][&#39;G&#39;] = 0.276839
            self.opt[&#39;RFe&#39;][&#39;RF&#39;] = rf_pulses.ge_90
            self.opt[&#39;RFr&#39;][&#39;RF&#39;] = rf_pulses.ge_180
            self.opt[&#39;Dz&#39;] = [0, 0.45]  # Slice thickness
        elif self.vendor == &#39;philips&#39;:
            self.opt[&#39;RFe&#39;][&#39;tau&#39;] = 3820 / 1e6
            self.opt[&#39;RFe&#39;][&#39;G&#39;] = 0.392
            self.opt[&#39;RFr&#39;][&#39;tau&#39;] = 6010 / 1e6
            self.opt[&#39;RFr&#39;][&#39;G&#39;] = 0.327
            self.opt[&#39;RFe&#39;][&#39;RF&#39;] = rf_pulses.philips_90
            self.opt[&#39;RFr&#39;][&#39;RF&#39;] = rf_pulses.philips_180
            self.opt[&#39;Dz&#39;] = [0, 0.45]
        elif self.vendor == &#39;siemens&#39;:
            self.opt[&#39;RFe&#39;][&#39;tau&#39;] = 3072 / 1e6
            self.opt[&#39;RFe&#39;][&#39;G&#39;] = 0.417
            self.opt[&#39;RFr&#39;][&#39;tau&#39;] = 3000 / 1e6
            self.opt[&#39;RFr&#39;][&#39;G&#39;] = 0.326
            self.opt[&#39;RFe&#39;][&#39;RF&#39;] = rf_pulses.ge_90
            self.opt[&#39;RFr&#39;][&#39;RF&#39;] = rf_pulses.ge_180
            self.opt[&#39;Dz&#39;] = [0, 0.5]
        else:
            warnings.warn(f&#39;{self.vendor} is not implemented. Please &#39;
                          f&#39;manually specify the models parameters.&#39;)

    def _set_rf(self, rf):
        dz = self.opt[&#39;Dz&#39;]
        nz = self.opt[&#39;Nz&#39;]
        nrf = self.opt[&#39;Nrf&#39;]

        gamma = 2 * np.pi * 42.575e6 / 10000  # Gauss
        z = np.linspace(dz[0], dz[1], nz)
        scale = rf[&#39;angle&#39;] / (gamma * rf[&#39;tau&#39;] * abs(np.sum(rf[&#39;RF&#39;])) / len(
            rf[&#39;RF&#39;]) * 180 / np.pi)
        rf[&#39;RF&#39;] *= scale

        m = np.zeros([3, nz])
        m[2, :] = 1
        rf[&#39;RF&#39;] = 1e-4 * rf[&#39;RF&#39;]  # approximation for
        # small tip angle

        phi = gamma * rf[&#39;G&#39;] * z * rf[&#39;tau&#39;] / nrf
        cphi = np.cos(phi)
        sphi = np.sin(phi)
        cp_rf = np.cos(rf[&#39;phase&#39;] * np.pi / 180)
        sp_rf = np.sin(rf[&#39;phase&#39;] * np.pi / 180)
        theta_rf = gamma * rf[&#39;RF&#39;] * rf[&#39;tau&#39;] / nrf
        ct_rf = np.cos(theta_rf)
        st_rf = np.sin(theta_rf)

        for i in range(nrf):
            for j in range(nz):
                rz = np.array([[cphi[j], sphi[j], 0],
                               [-sphi[j], cphi[j], 0],
                               [0, 0, 1]])
                m[:, j] = np.dot(rz, m[:, j])

            r = np.array([[1, 0, 0],
                          [0, ct_rf[i], st_rf[i]],
                          [0, -st_rf[i], ct_rf[i]]])
            if rf[&#39;phase&#39;] != 0:
                rz = np.array([[cp_rf, sp_rf, 0],
                               [-sp_rf, cp_rf, 0],
                               [0, 0, 1]])
                rzm = np.array([[cp_rf, -sp_rf, 0],
                                [sp_rf, cp_rf, 0],
                                [0, 0, 1]])
                r = np.dot(rzm, np.dot(r, rz))
            m = np.dot(r, m)

        if rf[&#39;ref&#39;] &gt; 0:
            psi = -rf[&#39;ref&#39;] / 2 * gamma * rf[&#39;G&#39;] * z * rf[&#39;tau&#39;]
            for j in range(nz):
                rz = np.array([[np.cos(psi[j]), np.sin(psi[j]), 0],
                               [-np.sin(psi[j]), np.cos(psi[j]), 0],
                               [0, 0, 1]])
                m[:, j] = np.dot(rz, m[:, j])

        rf[&#39;RF&#39;] = 1e4 * rf[&#39;RF&#39;]
        rf[&#39;alpha&#39;] = 1e4 * np.arccos(m[2, :])
        return rf


class T2StimFit:
    &#34;&#34;&#34;
    Attributes
    ----------
    t2_map : np.ndarray
        The estimated T2 values in ms
    m0_map : np.ndarray
        The estimated M0 values
    b1_map : np.ndarray
        The estimated B1 values where 1 represents the nominal flip angle
    b1_map_scaled : np.ndarray
        The estimated B1 values scaled to the range [0, 1] where 1 represents
        the nominal flip angle. All values over 1 are reflected about 1.
    r2_map : np.ndarray
        The R-Squared value of the fit, values close to 1 indicate a good
        fit, lower values indicate a poorer fit
    shape : tuple
        The shape of the T2 map
    n_vox : int
        The number of voxels in the map i.e. the product of all dimensions
        apart from TE
    &#34;&#34;&#34;
    def __init__(self, pixel_array, affine, model,
                 mask=None, multithread=&#39;auto&#39;, norm=True):
        &#34;&#34;&#34;
        Class for performing stimulated echo T2 fitting as in Marc Lebel R.
        StimFit: A Toolbox for Robust T2 Mapping with Stimulated Echo
        Compensation. In: Proc. Intl. Soc. Mag. Reson. Med. 20. Melbourne;
        2012:2558. https://archive.ismrm.org/2012/2558.html.

        Parameters
        ----------
        pixel_array : np.ndarray
            An array containing the signal from each voxel at each echo
            time with the last dimension being time i.e. the array needed to
            generate a 3D T2 map would have dimensions [x, y, z, TE].
        affine : np.ndarray
            A matrix giving the relationship between voxel coordinates and
            world coordinates.
        model : StimFitModel
            A StimFitModel object containing the model parameters.
        mask : np.ndarray, optional
            A boolean mask of the voxels to fit. Should be the shape of the
            desired T2 map rather than the raw data i.e. omit the time
            dimension.
        multithread : bool or &#39;auto&#39;, optional
            Default &#39;auto&#39;.
            If True, fitting will be distributed over all cores available on
            the node. If False, fitting will be carried out on a single thread.
            &#39;auto&#39; attempts to apply multithreading where appropriate based
            on the number of voxels being fit.
        norm : bool, optional
            Default True.
            StimFit is performed on normalised data. If norm is False,
            it is assumed that the data has already been normalised. If norm
            is True, the data will be normalised before fitting.
        &#34;&#34;&#34;
        self.pixel_array = np.copy(pixel_array)
        self.shape = pixel_array.shape[:-1]
        self.n_vox = np.prod(self.shape)
        self.affine = affine
        self.model = model

        assert multithread is True \
               or multithread is False \
               or multithread == &#39;auto&#39;, f&#39;multithreaded must be True,&#39; \
                                         f&#39;False or auto. You entered &#39; \
                                         f&#39;{multithread}&#39;
        if multithread == &#39;auto&#39;:
            if self.n_vox &gt; 20:
                multithread = True
            else:
                multithread = False
        self.multithread = multithread

        # Generate a mask if there isn&#39;t one specified
        if mask is None:
            self.mask = np.ones(self.shape, dtype=bool)
        else:
            self.mask = mask
            # Don&#39;t process any nan values
        self.mask[np.isnan(np.sum(pixel_array, axis=-1))] = False

        # Normalise the data
        if norm:
            self.pixel_array /= np.nanmax(self.pixel_array)

        if np.nanmax(self.pixel_array) &gt; 1:
            warnings.warn(&#39;Pixel array contains values greater than 1. &#39;
                          &#39;Data should be normalised, please set norm=True &#39;
                          &#39;or manually normalise your data.&#39;)

        # Perform the fit
        self._fit()

    def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;,
                 maps=&#39;all&#39;):
        &#34;&#34;&#34;Exports some of the T2StimFit class attributes to NIFTI.

        Parameters
        ----------
        output_directory : string, optional
            Path to the folder where the NIFTI files will be saved.
        base_file_name : string, optional
            Filename of the resulting NIFTI. This code appends the extension.
            Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
        maps : list or &#39;all&#39;, optional
            List of maps to save to NIFTI. This should either the string &#34;all&#34;
            or a list of maps from [&#34;t2&#34;, &#34;m0&#34;, &#34;b1&#34;, &#34;b1_scaled&#34;, &#34;r2&#34;,
            &#34;mask&#34;].
        &#34;&#34;&#34;
        os.makedirs(output_directory, exist_ok=True)
        base_path = os.path.join(output_directory, base_file_name)
        if maps == &#39;all&#39; or maps == [&#39;all&#39;]:
            maps = [&#39;t2&#39;, &#39;m0&#39;, &#39;b1&#39;, &#39;b1_scaled&#39;, &#39;r2&#39;, &#39;mask&#39;]
        if isinstance(maps, list):
            for result in maps:
                if result == &#39;t2&#39; or result == &#39;t2_map&#39;:
                    t2_nifti = nib.Nifti1Image(self.t2_map, affine=self.affine)
                    nib.save(t2_nifti, f&#39;{base_path}_t2_map.nii.gz&#39;)
                elif result == &#39;m0&#39; or result == &#39;m0_map&#39;:
                    m0_nifti = nib.Nifti1Image(self.m0_map, affine=self.affine)
                    nib.save(m0_nifti, f&#39;{base_path}_m0_map.nii.gz&#39;)
                elif result == &#39;b1&#39;:
                    b1_nifti = nib.Nifti1Image(self.b1_map,
                                               affine=self.affine)
                    nib.save(b1_nifti, f&#39;{base_path}_b1_map.nii.gz&#39;)
                elif result == &#39;b1_scaled&#39;:
                    b1_scaled_nifti = nib.Nifti1Image(self.b1_map_scaled,
                                                      affine=self.affine)
                    nib.save(b1_scaled_nifti,
                             f&#39;{base_path}_b1_map_scaled.nii.gz&#39;)
                elif result == &#39;r2&#39; or result == &#39;r2_map&#39;:
                    r2_nifti = nib.Nifti1Image(self.r2_map,
                                               affine=self.affine)
                    nib.save(r2_nifti, f&#39;{base_path}_r2_map.nii.gz&#39;)
                elif result == &#39;mask&#39;:
                    mask_nifti = nib.Nifti1Image(self.mask.astype(np.uint16),
                                                 affine=self.affine)
                    nib.save(mask_nifti, f&#39;{base_path}_mask.nii.gz&#39;)
        else:
            raise ValueError(&#39;No NIFTI file saved. The variable &#34;maps&#34; &#39;
                             &#39;should be &#34;all&#34; or a list of maps from &#39;
                             &#39;&#34;[&#34;t2&#34;, &#34;m0&#34;, &#34;b1&#34;, &#34;r2&#34;, &#39;
                             &#39;&#34;mask&#34;]&#34;.&#39;)

    def get_fit_signal(self):
        &#34;&#34;&#34;
        Get the fit signal from the model used to fit the data i.e. the
        simulated signal at each echo time given the estimated T2, M0. Note
        if norm=True, the fit signal will also be normalised.

        Returns
        -------
        fit_signal : np.ndarray
            An array containing the fit signal generated by the model
        &#34;&#34;&#34;
        fit_signal = np.zeros((self.n_vox, self.model.opt[&#39;etl&#39;]))
        params = np.array([self.t2_map.reshape(-1),
                           self.m0_map.reshape(-1)])

        for n in range(self.n_vox):
            fit_signal[n, :] = two_param_eq(self.model.opt[&#39;te&#39;] * 1000,
                                            params[0, n],
                                            params[1, n])
        fit_signal = fit_signal.reshape((*self.shape, self.model.opt[&#39;etl&#39;]))
        return fit_signal

    def _fit(self):
        mask = self.mask.flatten()
        signal = self.pixel_array.reshape(self.n_vox, self.model.opt[&#39;etl&#39;])
        idx = np.argwhere(mask).squeeze()
        signal = signal[idx, :]

        if self.multithread:
            with ProcessPool() as executor:
                results = executor.map(self._fit_signal, signal)
        else:
            results = list(tqdm(map(self._fit_signal, signal),
                                total=np.sum(self.mask)))
        t2 = np.array([result[0] for result in results])
        m0 = np.array([result[1] for result in results])
        b1 = np.array([result[2] for result in results])
        r2 = np.array([result[3] for result in results])

        if self.model.n_comp &gt; 1:
            t2_map = np.zeros((self.n_vox, self.model.n_comp))
            m0_map = np.zeros((self.n_vox, self.model.n_comp))
            r2_map = np.zeros((self.n_vox, self.model.n_comp))
        else:
            t2_map = np.zeros(self.n_vox)
            m0_map = np.zeros(self.n_vox)
            r2_map = np.zeros(self.n_vox)
        b1_map = np.zeros(self.n_vox)
        t2_map[idx] = t2 * 1000  # Convert to ms
        m0_map[idx] = m0
        b1_map[idx] = b1
        r2_map[idx] = r2
        self.t2_map = np.squeeze(t2_map.reshape((*self.shape,
                                                 self.model.n_comp)))
        self.m0_map = np.squeeze(m0_map.reshape((*self.shape,
                                                 self.model.n_comp)))
        self.b1_map = b1_map.reshape(self.shape)
        self.b1_map_scaled = rescale_b1_map(self.b1_map * 100)
        self.r2_map = np.squeeze(r2_map.reshape((*self.shape,
                                                 self.model.n_comp)))

    def _fit_signal(self, signal):
        if len(signal) != self.model.opt[&#39;etl&#39;]:
            raise Exception(&#39;Inconsistent echo train length&#39;)

        # Two component fitting
        if self.model.opt[&#39;lsq&#39;][&#39;Ncomp&#39;] == 2:
            x = optimize.least_squares(self._residual2,
                                       self.model.opt[&#39;lsq&#39;][&#39;X0&#39;],
                                       args=(signal, self.model.opt,
                                             self.model.mode),
                                       bounds=(self.model.opt[&#39;lsq&#39;][&#39;XL&#39;],
                                               self.model.opt[&#39;lsq&#39;][&#39;XU&#39;]),
                                       xtol=self.model.opt[&#39;lsq&#39;][&#39;xtol&#39;],
                                       ftol=self.model.opt[&#39;lsq&#39;][&#39;ftol&#39;]).x
            t2, amp, b1 = [x[0], x[2]], [x[1], x[3]], x[4]
            r2 = [r2_score(signal, two_param_eq(self.model.opt[&#39;te&#39;], t2[0],
                                                amp[0])),
                  r2_score(signal, two_param_eq(self.model.opt[&#39;te&#39;], t2[1],
                                                amp[1]))]

        # Three component fitting
        elif self.model.opt[&#39;lsq&#39;][&#39;Ncomp&#39;] == 3:
            x = optimize.least_squares(self._residual3,
                                       self.model.opt[&#39;lsq&#39;][&#39;X0&#39;],
                                       args=(signal, self.model.opt,
                                             self.model.mode),
                                       bounds=(self.model.opt[&#39;lsq&#39;][&#39;XL&#39;],
                                               self.model.opt[&#39;lsq&#39;][&#39;XU&#39;]),
                                       xtol=self.model.opt[&#39;lsq&#39;][&#39;xtol&#39;],
                                       ftol=self.model.opt[&#39;lsq&#39;][&#39;ftol&#39;]).x
            t2, amp, b1 = [x[0], x[2], x[4]], [x[1], x[3], x[5]], x[6]
            r2 = [r2_score(signal, two_param_eq(self.model.opt[&#39;te&#39;], t2[0],
                                                amp[0])),
                  r2_score(signal, two_param_eq(self.model.opt[&#39;te&#39;], t2[1],
                                                amp[1])),
                  r2_score(signal, two_param_eq(self.model.opt[&#39;te&#39;], t2[2],
                                                amp[2]))]

        # One component fitting
        else:
            x = optimize.least_squares(self._residual1,
                                       self.model.opt[&#39;lsq&#39;][&#39;X0&#39;],
                                       args=(signal, self.model.opt,
                                             self.model.mode),
                                       bounds=(self.model.opt[&#39;lsq&#39;][&#39;XL&#39;],
                                               self.model.opt[&#39;lsq&#39;][&#39;XU&#39;]),
                                       xtol=self.model.opt[&#39;lsq&#39;][&#39;xtol&#39;],
                                       ftol=self.model.opt[&#39;lsq&#39;][&#39;ftol&#39;]).x
            t2, amp, b1 = x
            fit_sig = two_param_eq(self.model.opt[&#39;te&#39;], t2, amp)
            r2 = r2_score(signal, fit_sig)
        return t2, amp, b1, r2

    @staticmethod
    def _residual1(p, y, opt, mode):
        return y - _epgsig(p[0], p[2], opt, mode) * p[1]

    @staticmethod
    def _residual2(p, y, opt, mode):
        return y - (_epgsig(p[0], p[4], opt, mode) * p[1] -
                    _epgsig(p[2], p[4], opt, mode) * p[3])

    @staticmethod
    def _residual3(p, y, opt, mode):
        return y - (_epgsig(p[0], p[6], opt, mode) * p[1] -
                    _epgsig(p[4], p[6], opt, mode) * p[5] -
                    _epgsig(p[2], p[6], opt, mode) * p[3])


def _epgsig(t2, b1, opt, mode):
    sig = np.zeros(opt[&#39;etl&#39;])
    if mode == &#39;non_selective&#39;:
        fa = np.pi / 180 * opt[&#39;RFr&#39;][&#39;angle&#39;] * np.array([
            opt[&#39;RFr&#39;][&#39;FA_array&#39;]])
        sig = _epg(t2, b1, opt[&#39;T1&#39;],
                   opt[&#39;esp&#39;], fa,
                   opt[&#39;RFe&#39;][&#39;angle&#39;] * np.pi / 180)
    elif mode == &#39;selective&#39;:
        fa = np.array([opt[&#39;RFr&#39;][&#39;alpha&#39;]]).T * \
             opt[&#39;RFr&#39;][&#39;FA_array&#39;]
        m = _epg(t2, b1, opt[&#39;T1&#39;], opt[&#39;esp&#39;],
                 fa, opt[&#39;RFe&#39;][&#39;alpha&#39;])
        sig = np.sum(m, 0) / opt[&#39;Nz&#39;]
    return sig.ravel()


@jit(nopython=True)
def _epg(x2, b1, x1, esp, ar, ae):  # TE = 6.425ms. TR = 1500ms.   90, 175,
    # 145, 110, 110, 110.
    echo_intensity = np.zeros(ar.shape, dtype=np.float64)
    omiga = np.zeros((ar.shape[0], 3, 1 + 2 * ar.shape[1]),
                     dtype=np.float64)
    ar = b1 * ar
    ae = b1 * ae
    x2 = np.exp(-0.5 * esp / x2)
    x1 = np.exp(-0.5 * esp / x1)

    for i in range(omiga.shape[2]):
        if i == 0:
            omiga[:, 0, i] = np.sin(ae)
            omiga[:, 1, i] = np.sin(ae)
            omiga[:, 2, i] = np.cos(ae)
            continue
        omiga[:, 0, 1:i + 1] = omiga[:, 0, 0:i]
        omiga[:, 1, 0:i] = omiga[:, 1, 1:i + 1]
        omiga[:, 0, 0] = np.conj(omiga[:, 1, 0])
        omiga[:, 0:2, :] = x2 * omiga[:, 0:2, :]
        omiga[:, 2, :] = x1 * omiga[:, 2, :]
        omiga[:, 2, 0] += 1 - x1
        if i % 2 == 1:
            for runs in range(ar.shape[0]):
                ari = ar[runs, i // 2]
                t = np.array(
                    [[np.cos(0.5 * ari) ** 2, np.sin(0.5 * ari) ** 2,
                      np.sin(ari)],
                     [np.sin(0.5 * ari) ** 2, np.cos(0.5 * ari) ** 2,
                      -np.sin(ari)],
                     [-0.5 * np.sin(ari), +0.5 * np.sin(ari),
                      np.cos(ari)]], dtype=np.float64)
                omiga[runs, :, :] = np.dot(t, np.ascontiguousarray(
                    omiga[runs, :, :]))
        if i % 2 == 0:
            echo_intensity[:, i // 2 - 1] = omiga[:, 0, 0]
    return echo_intensity</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ukat.mapping.t2_stimfit.StimFitModel"><code class="flex name class">
<span>class <span class="ident">StimFitModel</span></span>
<span>(</span><span>mode='non_selective', n_comp=1, ukrin_vendor=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class to set up the T2 StimFit model.</p>
<p>This model generates an optimisation dictionary (<code>opt</code>) containing the
model parameters and fitting options.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>{'non_selective', 'selective'}</code>, optional</dt>
<dd>Default 'non_selective'
Choose whether the refocusing pulses are selective on
non-selective.</dd>
<dt><strong><code>n_comp</code></strong> :&ensp;<code>{1, 2, 3}</code>, optional</dt>
<dd>Default 1
The number of components to fit e.g. if n_comp=2, the model will
estimate two T2 values, two M0 values and one B1 value per voxel.</dd>
<dt><strong><code>ukrin_vendor</code></strong> :&ensp;<code>{None, 'ge', 'philips', 'siemens'}</code>, optional</dt>
<dd>Default None
The vendor of the MRI scanner used to acquire the data if the UKRIN
protocol was used. Specifying a vendor at this stage overrides
the relevant parameters in the model with those from the UKRIN
protocol. If no vendor is specified, the default parameters are
used but can be manually updated after instantiation.</dd>
</dl>
<h2 id="key-parameters-in-options-dictionary">Key Parameters In Options Dictionary</h2>
<p>mode : {'non_selective', 'selective'}
Choose whether the refocusing pulses are slice selective or
non-selective.
esp : float
The echo spacing in seconds.
etl : int
The echo train length.
T1 : float
The approximate T1 value in seconds.
Dz : list
The start and end position of each slice in cm.
Nz : int
The number of positions along the slice profile to simulate signal
decay for.
Nrf : int
The number of resampled points in the RF waveform.
RFe : dict
The excitation pulse parameters, outlined below.
RFr : dict
The refocusing pulse parameters, outlined below.
lsq : dict
The least squares fitting parameters, outlined below.</p>
<h2 id="key-parameters-in-rfe-dictionary">Key Parameters In Rfe Dictionary</h2>
<p>RF : np.ndarray
The excitation pulse shape.
G : float
The amplitude of the excitation pulse in Gauss/cm.
tau : float
The excitation pulse duration in seconds.
phase : float
The relative phase of the excitation pulse in degrees (0 in CPMG).
angle : float
The flip angle of the excitation pulse in degrees (typically 90).
ref : float
The rephasing gradient fraction, times two. Near unity for
excitation.
alpha : list, optional
The actual tip angle distribution across the slice (degrees). If
not specified, the tip angle distribution is calculated.</p>
<h2 id="key-parameters-in-rfr-dictionary">Key Parameters In Rfr Dictionary</h2>
<p>RF : np.ndarray
The refocusing pulse shape.
G : float
The amplitude of the refocusing pulse in Gauss/cm.
tau : float
The refocusing pulse duration in seconds.
phase : float
The relative phase of the refocusing pulse in degrees (90 in CPMG).
angle : float
The flip angle of the refocusing pulse in degrees (typically 180).
ref : float
The rephasing gradient fraction, times two. Typically, 0 for
refocusing.
alpha : list, optional
The actual refocusing angle distribution across the slice
(degrees). If not specified, the tip angle distribution is
calculated.</p>
<h2 id="key-parameters-in-lsq-dictionary">Key Parameters In Lsq Dictionary</h2>
<p>Ncomp : int
The number of components to fit.
X0 : list
The initial guess for the fitting parameters in the order
[[T2_comp, M0_comp] * Ncomp, B1].
XL : list
The lower bounds for the fitting parameters in the order
[[T2_comp, M0_comp] * Ncomp, B1].
XU : list
The upper bounds for the fitting parameters in the order
[[T2_comp, M0_comp] * Ncomp, B1].
xtol : float
Tolerance for termination by the change of the independent
variables.
ftol : float
Tolerance for termination by the change of the cost function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StimFitModel:
    def __init__(self, mode=&#39;non_selective&#39;, n_comp=1, ukrin_vendor=None):
        &#34;&#34;&#34;
        A class to set up the T2 StimFit model.

        This model generates an optimisation dictionary (`opt`) containing the
        model parameters and fitting options.

        Parameters
        ----------
        mode : {&#39;non_selective&#39;, &#39;selective&#39;}, optional
            Default &#39;non_selective&#39;
            Choose whether the refocusing pulses are selective on
            non-selective.
        n_comp : {1, 2, 3}, optional
            Default 1
            The number of components to fit e.g. if n_comp=2, the model will
            estimate two T2 values, two M0 values and one B1 value per voxel.
        ukrin_vendor : {None, &#39;ge&#39;, &#39;philips&#39;, &#39;siemens&#39;}, optional
            Default None
            The vendor of the MRI scanner used to acquire the data if the UKRIN
            protocol was used. Specifying a vendor at this stage overrides
            the relevant parameters in the model with those from the UKRIN
            protocol. If no vendor is specified, the default parameters are
            used but can be manually updated after instantiation.

        Key Parameters in Options Dictionary
        ----------
        mode : {&#39;non_selective&#39;, &#39;selective&#39;}
            Choose whether the refocusing pulses are slice selective or
            non-selective.
        esp : float
            The echo spacing in seconds.
        etl : int
            The echo train length.
        T1 : float
            The approximate T1 value in seconds.
        Dz : list
            The start and end position of each slice in cm.
        Nz : int
            The number of positions along the slice profile to simulate signal
            decay for.
        Nrf : int
            The number of resampled points in the RF waveform.
        RFe : dict
            The excitation pulse parameters, outlined below.
        RFr : dict
            The refocusing pulse parameters, outlined below.
        lsq : dict
            The least squares fitting parameters, outlined below.

        Key Parameters in RFe Dictionary
        ----------
        RF : np.ndarray
            The excitation pulse shape.
        G : float
            The amplitude of the excitation pulse in Gauss/cm.
        tau : float
            The excitation pulse duration in seconds.
        phase : float
            The relative phase of the excitation pulse in degrees (0 in CPMG).
        angle : float
            The flip angle of the excitation pulse in degrees (typically 90).
        ref : float
            The rephasing gradient fraction, times two. Near unity for
            excitation.
        alpha : list, optional
            The actual tip angle distribution across the slice (degrees). If
            not specified, the tip angle distribution is calculated.

        Key Parameters in RFr Dictionary
        ----------
        RF : np.ndarray
            The refocusing pulse shape.
        G : float
            The amplitude of the refocusing pulse in Gauss/cm.
        tau : float
            The refocusing pulse duration in seconds.
        phase : float
            The relative phase of the refocusing pulse in degrees (90 in CPMG).
        angle : float
            The flip angle of the refocusing pulse in degrees (typically 180).
        ref : float
            The rephasing gradient fraction, times two. Typically, 0 for
            refocusing.
        alpha : list, optional
            The actual refocusing angle distribution across the slice
            (degrees). If not specified, the tip angle distribution is
            calculated.

        Key Parameters in lsq Dictionary
        ----------
        Ncomp : int
            The number of components to fit.
        X0 : list
            The initial guess for the fitting parameters in the order
            [[T2_comp, M0_comp] * Ncomp, B1].
        XL : list
            The lower bounds for the fitting parameters in the order
            [[T2_comp, M0_comp] * Ncomp, B1].
        XU : list
            The upper bounds for the fitting parameters in the order
            [[T2_comp, M0_comp] * Ncomp, B1].
        xtol : float
            Tolerance for termination by the change of the independent
            variables.
        ftol : float
            Tolerance for termination by the change of the cost function.
        &#34;&#34;&#34;
        if mode != &#39;non_selective&#39; and mode != &#39;selective&#39;:
            raise ValueError(f&#39;mode must be either &#34;non_selective&#34; or &#39;
                             f&#39;&#34;selective&#34;. You specified {mode}.&#39;)
        self.mode = mode
        if n_comp not in [1, 2, 3]:
            raise ValueError(f&#39;n_comp must be either 1, 2 or 3. You specified &#39;
                             f&#39;{n_comp}.&#39;)
        self.n_comp = n_comp
        if ukrin_vendor not in [&#39;ge&#39;, &#39;philips&#39;, &#39;siemens&#39;]:
            warnings.warn(&#39;ukrin_vendor was not specified. Using default &#39;
                          &#39;pulse sequence parameters.&#39;)
        self.opt = dict()
        self.opt[&#39;mode&#39;] = self.mode
        self.opt[&#39;esp&#39;] = 10e-3
        self.opt[&#39;etl&#39;] = 20
        self.opt[&#39;T1&#39;] = 3

        self.opt[&#39;RFe&#39;] = dict()
        self.opt[&#39;RFr&#39;] = dict()
        if self.mode == &#39;selective&#39;:
            self.opt[&#39;Dz&#39;] = [-0.5, 0.5]
            self.opt[&#39;Nz&#39;] = 51
            self.opt[&#39;Nrf&#39;] = 64
            self.opt[&#39;RFe&#39;] = {&#39;RF&#39;: [],
                               &#39;tau&#39;: 2e-3,
                               &#39;G&#39;: 0.5,
                               &#39;phase&#39;: 0,
                               &#39;ref&#39;: 1,
                               &#39;alpha&#39;: [],
                               &#39;angle&#39;: 90}
            self.opt[&#39;RFr&#39;] = {&#39;RF&#39;: [],
                               &#39;tau&#39;: 2e-3,
                               &#39;G&#39;: 0.5,
                               &#39;phase&#39;: 90,
                               &#39;ref&#39;: 0,
                               &#39;alpha&#39;: [],
                               &#39;angle&#39;: 180,
                               &#39;FA_array&#39;: np.ones(self.opt[&#39;etl&#39;])}
        else:
            self.opt[&#39;RFe&#39;] = {&#39;angle&#39;: 90}
            self.opt[&#39;RFr&#39;] = {&#39;angle&#39;: 180,
                               &#39;FA_array&#39;: np.ones(self.opt[&#39;etl&#39;])}
        # Curve fitting parameters
        self.opt[&#39;lsq&#39;] = {&#39;Ncomp&#39;: n_comp,
                           &#39;xtol&#39;: 5e-4,
                           &#39;ftol&#39;: 1e-9}
        if self.opt[&#39;lsq&#39;][&#39;Ncomp&#39;] == 1:
            # [T2(sec), amp, B1]
            self.opt[&#39;lsq&#39;][&#39;X0&#39;] = [0.06, 0.1, 1]
            self.opt[&#39;lsq&#39;][&#39;XU&#39;] = [3, 1e+3, 1.8]
            self.opt[&#39;lsq&#39;][&#39;XL&#39;] = [0.015, 0, 0.2]
        elif self.opt[&#39;lsq&#39;][&#39;Ncomp&#39;] == 2:
            # [T2, amp, T2, amp, B1]
            self.opt[&#39;lsq&#39;][&#39;X0&#39;] = [0.02, 0.1, 0.331, 0.1, 1]
            self.opt[&#39;lsq&#39;][&#39;XU&#39;] = [0.25, 1e+3, 3, 1e+3, 1.8]
            self.opt[&#39;lsq&#39;][&#39;XL&#39;] = [0.015, 0, 0.25, 0, 0.2]
        elif self.opt[&#39;lsq&#39;][&#39;Ncomp&#39;] == 3:
            # [T2, amp, T2, amp, T2, amp, B1]
            self.opt[&#39;lsq&#39;][&#39;X0&#39;] = [0.02, 0.1, 0.036, 0.1, 0.131, 0.1, 1]
            self.opt[&#39;lsq&#39;][&#39;XU&#39;] = [0.035, 1e+3, 0.13, 1e3, 3, 1e+3, 1.8]
            self.opt[&#39;lsq&#39;][&#39;XL&#39;] = [0.015, 0, 0.035, 0, 0.13, 0, 0.2]

        if ukrin_vendor is not None:
            self._set_ukrin_vendor(ukrin_vendor)
            if self.mode == &#39;selective&#39;:
                self.opt[&#39;RFe&#39;] = self._set_rf(self.opt[&#39;RFe&#39;])
                self.opt[&#39;RFr&#39;] = self._set_rf(self.opt[&#39;RFr&#39;])

    def get_opt(self):
        return self.opt

    def get_lsq(self):
        return self.opt[&#39;lsq&#39;]

    def get_rfe(self):
        return self.opt[&#39;RFe&#39;]

    def get_rfr(self):
        return self.opt[&#39;RFr&#39;]

    def _set_ukrin_vendor(self, vendor):
        self.vendor = vendor
        self.opt[&#39;T1&#39;] = 1.5
        self.opt[&#39;esp&#39;] = 0.0129
        self.opt[&#39;etl&#39;] = 10
        self.opt[&#39;te&#39;] = (np.arange(self.opt[&#39;etl&#39;]) + 1) * self.opt[&#39;esp&#39;]
        self.opt[&#39;RFr&#39;][&#39;FA_array&#39;] = np.ones(self.opt[&#39;etl&#39;])
        if self.vendor == &#39;ge&#39;:
            self.opt[&#39;RFe&#39;][&#39;tau&#39;] = 2000 / 1e6  # Duration
            self.opt[&#39;RFe&#39;][&#39;G&#39;] = 0.751599  # Amplitude
            self.opt[&#39;RFr&#39;][&#39;tau&#39;] = 3136 / 1e6
            self.opt[&#39;RFr&#39;][&#39;G&#39;] = 0.276839
            self.opt[&#39;RFe&#39;][&#39;RF&#39;] = rf_pulses.ge_90
            self.opt[&#39;RFr&#39;][&#39;RF&#39;] = rf_pulses.ge_180
            self.opt[&#39;Dz&#39;] = [0, 0.45]  # Slice thickness
        elif self.vendor == &#39;philips&#39;:
            self.opt[&#39;RFe&#39;][&#39;tau&#39;] = 3820 / 1e6
            self.opt[&#39;RFe&#39;][&#39;G&#39;] = 0.392
            self.opt[&#39;RFr&#39;][&#39;tau&#39;] = 6010 / 1e6
            self.opt[&#39;RFr&#39;][&#39;G&#39;] = 0.327
            self.opt[&#39;RFe&#39;][&#39;RF&#39;] = rf_pulses.philips_90
            self.opt[&#39;RFr&#39;][&#39;RF&#39;] = rf_pulses.philips_180
            self.opt[&#39;Dz&#39;] = [0, 0.45]
        elif self.vendor == &#39;siemens&#39;:
            self.opt[&#39;RFe&#39;][&#39;tau&#39;] = 3072 / 1e6
            self.opt[&#39;RFe&#39;][&#39;G&#39;] = 0.417
            self.opt[&#39;RFr&#39;][&#39;tau&#39;] = 3000 / 1e6
            self.opt[&#39;RFr&#39;][&#39;G&#39;] = 0.326
            self.opt[&#39;RFe&#39;][&#39;RF&#39;] = rf_pulses.ge_90
            self.opt[&#39;RFr&#39;][&#39;RF&#39;] = rf_pulses.ge_180
            self.opt[&#39;Dz&#39;] = [0, 0.5]
        else:
            warnings.warn(f&#39;{self.vendor} is not implemented. Please &#39;
                          f&#39;manually specify the models parameters.&#39;)

    def _set_rf(self, rf):
        dz = self.opt[&#39;Dz&#39;]
        nz = self.opt[&#39;Nz&#39;]
        nrf = self.opt[&#39;Nrf&#39;]

        gamma = 2 * np.pi * 42.575e6 / 10000  # Gauss
        z = np.linspace(dz[0], dz[1], nz)
        scale = rf[&#39;angle&#39;] / (gamma * rf[&#39;tau&#39;] * abs(np.sum(rf[&#39;RF&#39;])) / len(
            rf[&#39;RF&#39;]) * 180 / np.pi)
        rf[&#39;RF&#39;] *= scale

        m = np.zeros([3, nz])
        m[2, :] = 1
        rf[&#39;RF&#39;] = 1e-4 * rf[&#39;RF&#39;]  # approximation for
        # small tip angle

        phi = gamma * rf[&#39;G&#39;] * z * rf[&#39;tau&#39;] / nrf
        cphi = np.cos(phi)
        sphi = np.sin(phi)
        cp_rf = np.cos(rf[&#39;phase&#39;] * np.pi / 180)
        sp_rf = np.sin(rf[&#39;phase&#39;] * np.pi / 180)
        theta_rf = gamma * rf[&#39;RF&#39;] * rf[&#39;tau&#39;] / nrf
        ct_rf = np.cos(theta_rf)
        st_rf = np.sin(theta_rf)

        for i in range(nrf):
            for j in range(nz):
                rz = np.array([[cphi[j], sphi[j], 0],
                               [-sphi[j], cphi[j], 0],
                               [0, 0, 1]])
                m[:, j] = np.dot(rz, m[:, j])

            r = np.array([[1, 0, 0],
                          [0, ct_rf[i], st_rf[i]],
                          [0, -st_rf[i], ct_rf[i]]])
            if rf[&#39;phase&#39;] != 0:
                rz = np.array([[cp_rf, sp_rf, 0],
                               [-sp_rf, cp_rf, 0],
                               [0, 0, 1]])
                rzm = np.array([[cp_rf, -sp_rf, 0],
                                [sp_rf, cp_rf, 0],
                                [0, 0, 1]])
                r = np.dot(rzm, np.dot(r, rz))
            m = np.dot(r, m)

        if rf[&#39;ref&#39;] &gt; 0:
            psi = -rf[&#39;ref&#39;] / 2 * gamma * rf[&#39;G&#39;] * z * rf[&#39;tau&#39;]
            for j in range(nz):
                rz = np.array([[np.cos(psi[j]), np.sin(psi[j]), 0],
                               [-np.sin(psi[j]), np.cos(psi[j]), 0],
                               [0, 0, 1]])
                m[:, j] = np.dot(rz, m[:, j])

        rf[&#39;RF&#39;] = 1e4 * rf[&#39;RF&#39;]
        rf[&#39;alpha&#39;] = 1e4 * np.arccos(m[2, :])
        return rf</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ukat.mapping.t2_stimfit.StimFitModel.get_lsq"><code class="name flex">
<span>def <span class="ident">get_lsq</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_lsq(self):
    return self.opt[&#39;lsq&#39;]</code></pre>
</details>
</dd>
<dt id="ukat.mapping.t2_stimfit.StimFitModel.get_opt"><code class="name flex">
<span>def <span class="ident">get_opt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_opt(self):
    return self.opt</code></pre>
</details>
</dd>
<dt id="ukat.mapping.t2_stimfit.StimFitModel.get_rfe"><code class="name flex">
<span>def <span class="ident">get_rfe</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rfe(self):
    return self.opt[&#39;RFe&#39;]</code></pre>
</details>
</dd>
<dt id="ukat.mapping.t2_stimfit.StimFitModel.get_rfr"><code class="name flex">
<span>def <span class="ident">get_rfr</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rfr(self):
    return self.opt[&#39;RFr&#39;]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ukat.mapping.t2_stimfit.T2StimFit"><code class="flex name class">
<span>class <span class="ident">T2StimFit</span></span>
<span>(</span><span>pixel_array, affine, model, mask=None, multithread='auto', norm=True)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>t2_map</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The estimated T2 values in ms</dd>
<dt><strong><code>m0_map</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The estimated M0 values</dd>
<dt><strong><code>b1_map</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The estimated B1 values where 1 represents the nominal flip angle</dd>
<dt><strong><code>b1_map_scaled</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The estimated B1 values scaled to the range [0, 1] where 1 represents
the nominal flip angle. All values over 1 are reflected about 1.</dd>
<dt><strong><code>r2_map</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The R-Squared value of the fit, values close to 1 indicate a good
fit, lower values indicate a poorer fit</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The shape of the T2 map</dd>
<dt><strong><code>n_vox</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of voxels in the map i.e. the product of all dimensions
apart from TE</dd>
<dt>Class for performing stimulated echo T2 fitting as in Marc Lebel R.</dt>
<dt><strong><code>StimFit</code></strong> :&ensp;<code>A Toolbox for Robust T2 Mapping with Stimulated Echo</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Compensation. In: Proc. Intl. Soc. Mag. Reson. Med. 20. Melbourne;
2012:2558. <a href="https://archive.ismrm.org/2012/2558.html.">https://archive.ismrm.org/2012/2558.html.</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pixel_array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>An array containing the signal from each voxel at each echo
time with the last dimension being time i.e. the array needed to
generate a 3D T2 map would have dimensions [x, y, z, TE].</dd>
<dt><strong><code>affine</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A matrix giving the relationship between voxel coordinates and
world coordinates.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="ukat.mapping.t2_stimfit.StimFitModel" href="#ukat.mapping.t2_stimfit.StimFitModel">StimFitModel</a></code></dt>
<dd>A StimFitModel object containing the model parameters.</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>np.ndarray</code>, optional</dt>
<dd>A boolean mask of the voxels to fit. Should be the shape of the
desired T2 map rather than the raw data i.e. omit the time
dimension.</dd>
<dt><strong><code>multithread</code></strong> :&ensp;<code>bool</code> or <code>'auto'</code>, optional</dt>
<dd>Default 'auto'.
If True, fitting will be distributed over all cores available on
the node. If False, fitting will be carried out on a single thread.
'auto' attempts to apply multithreading where appropriate based
on the number of voxels being fit.</dd>
<dt><strong><code>norm</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Default True.
StimFit is performed on normalised data. If norm is False,
it is assumed that the data has already been normalised. If norm
is True, the data will be normalised before fitting.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class T2StimFit:
    &#34;&#34;&#34;
    Attributes
    ----------
    t2_map : np.ndarray
        The estimated T2 values in ms
    m0_map : np.ndarray
        The estimated M0 values
    b1_map : np.ndarray
        The estimated B1 values where 1 represents the nominal flip angle
    b1_map_scaled : np.ndarray
        The estimated B1 values scaled to the range [0, 1] where 1 represents
        the nominal flip angle. All values over 1 are reflected about 1.
    r2_map : np.ndarray
        The R-Squared value of the fit, values close to 1 indicate a good
        fit, lower values indicate a poorer fit
    shape : tuple
        The shape of the T2 map
    n_vox : int
        The number of voxels in the map i.e. the product of all dimensions
        apart from TE
    &#34;&#34;&#34;
    def __init__(self, pixel_array, affine, model,
                 mask=None, multithread=&#39;auto&#39;, norm=True):
        &#34;&#34;&#34;
        Class for performing stimulated echo T2 fitting as in Marc Lebel R.
        StimFit: A Toolbox for Robust T2 Mapping with Stimulated Echo
        Compensation. In: Proc. Intl. Soc. Mag. Reson. Med. 20. Melbourne;
        2012:2558. https://archive.ismrm.org/2012/2558.html.

        Parameters
        ----------
        pixel_array : np.ndarray
            An array containing the signal from each voxel at each echo
            time with the last dimension being time i.e. the array needed to
            generate a 3D T2 map would have dimensions [x, y, z, TE].
        affine : np.ndarray
            A matrix giving the relationship between voxel coordinates and
            world coordinates.
        model : StimFitModel
            A StimFitModel object containing the model parameters.
        mask : np.ndarray, optional
            A boolean mask of the voxels to fit. Should be the shape of the
            desired T2 map rather than the raw data i.e. omit the time
            dimension.
        multithread : bool or &#39;auto&#39;, optional
            Default &#39;auto&#39;.
            If True, fitting will be distributed over all cores available on
            the node. If False, fitting will be carried out on a single thread.
            &#39;auto&#39; attempts to apply multithreading where appropriate based
            on the number of voxels being fit.
        norm : bool, optional
            Default True.
            StimFit is performed on normalised data. If norm is False,
            it is assumed that the data has already been normalised. If norm
            is True, the data will be normalised before fitting.
        &#34;&#34;&#34;
        self.pixel_array = np.copy(pixel_array)
        self.shape = pixel_array.shape[:-1]
        self.n_vox = np.prod(self.shape)
        self.affine = affine
        self.model = model

        assert multithread is True \
               or multithread is False \
               or multithread == &#39;auto&#39;, f&#39;multithreaded must be True,&#39; \
                                         f&#39;False or auto. You entered &#39; \
                                         f&#39;{multithread}&#39;
        if multithread == &#39;auto&#39;:
            if self.n_vox &gt; 20:
                multithread = True
            else:
                multithread = False
        self.multithread = multithread

        # Generate a mask if there isn&#39;t one specified
        if mask is None:
            self.mask = np.ones(self.shape, dtype=bool)
        else:
            self.mask = mask
            # Don&#39;t process any nan values
        self.mask[np.isnan(np.sum(pixel_array, axis=-1))] = False

        # Normalise the data
        if norm:
            self.pixel_array /= np.nanmax(self.pixel_array)

        if np.nanmax(self.pixel_array) &gt; 1:
            warnings.warn(&#39;Pixel array contains values greater than 1. &#39;
                          &#39;Data should be normalised, please set norm=True &#39;
                          &#39;or manually normalise your data.&#39;)

        # Perform the fit
        self._fit()

    def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;,
                 maps=&#39;all&#39;):
        &#34;&#34;&#34;Exports some of the T2StimFit class attributes to NIFTI.

        Parameters
        ----------
        output_directory : string, optional
            Path to the folder where the NIFTI files will be saved.
        base_file_name : string, optional
            Filename of the resulting NIFTI. This code appends the extension.
            Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
        maps : list or &#39;all&#39;, optional
            List of maps to save to NIFTI. This should either the string &#34;all&#34;
            or a list of maps from [&#34;t2&#34;, &#34;m0&#34;, &#34;b1&#34;, &#34;b1_scaled&#34;, &#34;r2&#34;,
            &#34;mask&#34;].
        &#34;&#34;&#34;
        os.makedirs(output_directory, exist_ok=True)
        base_path = os.path.join(output_directory, base_file_name)
        if maps == &#39;all&#39; or maps == [&#39;all&#39;]:
            maps = [&#39;t2&#39;, &#39;m0&#39;, &#39;b1&#39;, &#39;b1_scaled&#39;, &#39;r2&#39;, &#39;mask&#39;]
        if isinstance(maps, list):
            for result in maps:
                if result == &#39;t2&#39; or result == &#39;t2_map&#39;:
                    t2_nifti = nib.Nifti1Image(self.t2_map, affine=self.affine)
                    nib.save(t2_nifti, f&#39;{base_path}_t2_map.nii.gz&#39;)
                elif result == &#39;m0&#39; or result == &#39;m0_map&#39;:
                    m0_nifti = nib.Nifti1Image(self.m0_map, affine=self.affine)
                    nib.save(m0_nifti, f&#39;{base_path}_m0_map.nii.gz&#39;)
                elif result == &#39;b1&#39;:
                    b1_nifti = nib.Nifti1Image(self.b1_map,
                                               affine=self.affine)
                    nib.save(b1_nifti, f&#39;{base_path}_b1_map.nii.gz&#39;)
                elif result == &#39;b1_scaled&#39;:
                    b1_scaled_nifti = nib.Nifti1Image(self.b1_map_scaled,
                                                      affine=self.affine)
                    nib.save(b1_scaled_nifti,
                             f&#39;{base_path}_b1_map_scaled.nii.gz&#39;)
                elif result == &#39;r2&#39; or result == &#39;r2_map&#39;:
                    r2_nifti = nib.Nifti1Image(self.r2_map,
                                               affine=self.affine)
                    nib.save(r2_nifti, f&#39;{base_path}_r2_map.nii.gz&#39;)
                elif result == &#39;mask&#39;:
                    mask_nifti = nib.Nifti1Image(self.mask.astype(np.uint16),
                                                 affine=self.affine)
                    nib.save(mask_nifti, f&#39;{base_path}_mask.nii.gz&#39;)
        else:
            raise ValueError(&#39;No NIFTI file saved. The variable &#34;maps&#34; &#39;
                             &#39;should be &#34;all&#34; or a list of maps from &#39;
                             &#39;&#34;[&#34;t2&#34;, &#34;m0&#34;, &#34;b1&#34;, &#34;r2&#34;, &#39;
                             &#39;&#34;mask&#34;]&#34;.&#39;)

    def get_fit_signal(self):
        &#34;&#34;&#34;
        Get the fit signal from the model used to fit the data i.e. the
        simulated signal at each echo time given the estimated T2, M0. Note
        if norm=True, the fit signal will also be normalised.

        Returns
        -------
        fit_signal : np.ndarray
            An array containing the fit signal generated by the model
        &#34;&#34;&#34;
        fit_signal = np.zeros((self.n_vox, self.model.opt[&#39;etl&#39;]))
        params = np.array([self.t2_map.reshape(-1),
                           self.m0_map.reshape(-1)])

        for n in range(self.n_vox):
            fit_signal[n, :] = two_param_eq(self.model.opt[&#39;te&#39;] * 1000,
                                            params[0, n],
                                            params[1, n])
        fit_signal = fit_signal.reshape((*self.shape, self.model.opt[&#39;etl&#39;]))
        return fit_signal

    def _fit(self):
        mask = self.mask.flatten()
        signal = self.pixel_array.reshape(self.n_vox, self.model.opt[&#39;etl&#39;])
        idx = np.argwhere(mask).squeeze()
        signal = signal[idx, :]

        if self.multithread:
            with ProcessPool() as executor:
                results = executor.map(self._fit_signal, signal)
        else:
            results = list(tqdm(map(self._fit_signal, signal),
                                total=np.sum(self.mask)))
        t2 = np.array([result[0] for result in results])
        m0 = np.array([result[1] for result in results])
        b1 = np.array([result[2] for result in results])
        r2 = np.array([result[3] for result in results])

        if self.model.n_comp &gt; 1:
            t2_map = np.zeros((self.n_vox, self.model.n_comp))
            m0_map = np.zeros((self.n_vox, self.model.n_comp))
            r2_map = np.zeros((self.n_vox, self.model.n_comp))
        else:
            t2_map = np.zeros(self.n_vox)
            m0_map = np.zeros(self.n_vox)
            r2_map = np.zeros(self.n_vox)
        b1_map = np.zeros(self.n_vox)
        t2_map[idx] = t2 * 1000  # Convert to ms
        m0_map[idx] = m0
        b1_map[idx] = b1
        r2_map[idx] = r2
        self.t2_map = np.squeeze(t2_map.reshape((*self.shape,
                                                 self.model.n_comp)))
        self.m0_map = np.squeeze(m0_map.reshape((*self.shape,
                                                 self.model.n_comp)))
        self.b1_map = b1_map.reshape(self.shape)
        self.b1_map_scaled = rescale_b1_map(self.b1_map * 100)
        self.r2_map = np.squeeze(r2_map.reshape((*self.shape,
                                                 self.model.n_comp)))

    def _fit_signal(self, signal):
        if len(signal) != self.model.opt[&#39;etl&#39;]:
            raise Exception(&#39;Inconsistent echo train length&#39;)

        # Two component fitting
        if self.model.opt[&#39;lsq&#39;][&#39;Ncomp&#39;] == 2:
            x = optimize.least_squares(self._residual2,
                                       self.model.opt[&#39;lsq&#39;][&#39;X0&#39;],
                                       args=(signal, self.model.opt,
                                             self.model.mode),
                                       bounds=(self.model.opt[&#39;lsq&#39;][&#39;XL&#39;],
                                               self.model.opt[&#39;lsq&#39;][&#39;XU&#39;]),
                                       xtol=self.model.opt[&#39;lsq&#39;][&#39;xtol&#39;],
                                       ftol=self.model.opt[&#39;lsq&#39;][&#39;ftol&#39;]).x
            t2, amp, b1 = [x[0], x[2]], [x[1], x[3]], x[4]
            r2 = [r2_score(signal, two_param_eq(self.model.opt[&#39;te&#39;], t2[0],
                                                amp[0])),
                  r2_score(signal, two_param_eq(self.model.opt[&#39;te&#39;], t2[1],
                                                amp[1]))]

        # Three component fitting
        elif self.model.opt[&#39;lsq&#39;][&#39;Ncomp&#39;] == 3:
            x = optimize.least_squares(self._residual3,
                                       self.model.opt[&#39;lsq&#39;][&#39;X0&#39;],
                                       args=(signal, self.model.opt,
                                             self.model.mode),
                                       bounds=(self.model.opt[&#39;lsq&#39;][&#39;XL&#39;],
                                               self.model.opt[&#39;lsq&#39;][&#39;XU&#39;]),
                                       xtol=self.model.opt[&#39;lsq&#39;][&#39;xtol&#39;],
                                       ftol=self.model.opt[&#39;lsq&#39;][&#39;ftol&#39;]).x
            t2, amp, b1 = [x[0], x[2], x[4]], [x[1], x[3], x[5]], x[6]
            r2 = [r2_score(signal, two_param_eq(self.model.opt[&#39;te&#39;], t2[0],
                                                amp[0])),
                  r2_score(signal, two_param_eq(self.model.opt[&#39;te&#39;], t2[1],
                                                amp[1])),
                  r2_score(signal, two_param_eq(self.model.opt[&#39;te&#39;], t2[2],
                                                amp[2]))]

        # One component fitting
        else:
            x = optimize.least_squares(self._residual1,
                                       self.model.opt[&#39;lsq&#39;][&#39;X0&#39;],
                                       args=(signal, self.model.opt,
                                             self.model.mode),
                                       bounds=(self.model.opt[&#39;lsq&#39;][&#39;XL&#39;],
                                               self.model.opt[&#39;lsq&#39;][&#39;XU&#39;]),
                                       xtol=self.model.opt[&#39;lsq&#39;][&#39;xtol&#39;],
                                       ftol=self.model.opt[&#39;lsq&#39;][&#39;ftol&#39;]).x
            t2, amp, b1 = x
            fit_sig = two_param_eq(self.model.opt[&#39;te&#39;], t2, amp)
            r2 = r2_score(signal, fit_sig)
        return t2, amp, b1, r2

    @staticmethod
    def _residual1(p, y, opt, mode):
        return y - _epgsig(p[0], p[2], opt, mode) * p[1]

    @staticmethod
    def _residual2(p, y, opt, mode):
        return y - (_epgsig(p[0], p[4], opt, mode) * p[1] -
                    _epgsig(p[2], p[4], opt, mode) * p[3])

    @staticmethod
    def _residual3(p, y, opt, mode):
        return y - (_epgsig(p[0], p[6], opt, mode) * p[1] -
                    _epgsig(p[4], p[6], opt, mode) * p[5] -
                    _epgsig(p[2], p[6], opt, mode) * p[3])</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ukat.mapping.t2_stimfit.T2StimFit.get_fit_signal"><code class="name flex">
<span>def <span class="ident">get_fit_signal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the fit signal from the model used to fit the data i.e. the
simulated signal at each echo time given the estimated T2, M0. Note
if norm=True, the fit signal will also be normalised.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fit_signal</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>An array containing the fit signal generated by the model</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fit_signal(self):
    &#34;&#34;&#34;
    Get the fit signal from the model used to fit the data i.e. the
    simulated signal at each echo time given the estimated T2, M0. Note
    if norm=True, the fit signal will also be normalised.

    Returns
    -------
    fit_signal : np.ndarray
        An array containing the fit signal generated by the model
    &#34;&#34;&#34;
    fit_signal = np.zeros((self.n_vox, self.model.opt[&#39;etl&#39;]))
    params = np.array([self.t2_map.reshape(-1),
                       self.m0_map.reshape(-1)])

    for n in range(self.n_vox):
        fit_signal[n, :] = two_param_eq(self.model.opt[&#39;te&#39;] * 1000,
                                        params[0, n],
                                        params[1, n])
    fit_signal = fit_signal.reshape((*self.shape, self.model.opt[&#39;etl&#39;]))
    return fit_signal</code></pre>
</details>
</dd>
<dt id="ukat.mapping.t2_stimfit.T2StimFit.to_nifti"><code class="name flex">
<span>def <span class="ident">to_nifti</span></span>(<span>self, output_directory='/home/runner/work/ukat/ukat', base_file_name='Output', maps='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Exports some of the T2StimFit class attributes to NIFTI.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>output_directory</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Path to the folder where the NIFTI files will be saved.</dd>
<dt><strong><code>base_file_name</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Filename of the resulting NIFTI. This code appends the extension.
Eg., base_file_name = 'Output' will result in 'Output.nii.gz'.</dd>
<dt><strong><code>maps</code></strong> :&ensp;<code>list</code> or <code>'all'</code>, optional</dt>
<dd>List of maps to save to NIFTI. This should either the string "all"
or a list of maps from ["t2", "m0", "b1", "b1_scaled", "r2",
"mask"].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;,
             maps=&#39;all&#39;):
    &#34;&#34;&#34;Exports some of the T2StimFit class attributes to NIFTI.

    Parameters
    ----------
    output_directory : string, optional
        Path to the folder where the NIFTI files will be saved.
    base_file_name : string, optional
        Filename of the resulting NIFTI. This code appends the extension.
        Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
    maps : list or &#39;all&#39;, optional
        List of maps to save to NIFTI. This should either the string &#34;all&#34;
        or a list of maps from [&#34;t2&#34;, &#34;m0&#34;, &#34;b1&#34;, &#34;b1_scaled&#34;, &#34;r2&#34;,
        &#34;mask&#34;].
    &#34;&#34;&#34;
    os.makedirs(output_directory, exist_ok=True)
    base_path = os.path.join(output_directory, base_file_name)
    if maps == &#39;all&#39; or maps == [&#39;all&#39;]:
        maps = [&#39;t2&#39;, &#39;m0&#39;, &#39;b1&#39;, &#39;b1_scaled&#39;, &#39;r2&#39;, &#39;mask&#39;]
    if isinstance(maps, list):
        for result in maps:
            if result == &#39;t2&#39; or result == &#39;t2_map&#39;:
                t2_nifti = nib.Nifti1Image(self.t2_map, affine=self.affine)
                nib.save(t2_nifti, f&#39;{base_path}_t2_map.nii.gz&#39;)
            elif result == &#39;m0&#39; or result == &#39;m0_map&#39;:
                m0_nifti = nib.Nifti1Image(self.m0_map, affine=self.affine)
                nib.save(m0_nifti, f&#39;{base_path}_m0_map.nii.gz&#39;)
            elif result == &#39;b1&#39;:
                b1_nifti = nib.Nifti1Image(self.b1_map,
                                           affine=self.affine)
                nib.save(b1_nifti, f&#39;{base_path}_b1_map.nii.gz&#39;)
            elif result == &#39;b1_scaled&#39;:
                b1_scaled_nifti = nib.Nifti1Image(self.b1_map_scaled,
                                                  affine=self.affine)
                nib.save(b1_scaled_nifti,
                         f&#39;{base_path}_b1_map_scaled.nii.gz&#39;)
            elif result == &#39;r2&#39; or result == &#39;r2_map&#39;:
                r2_nifti = nib.Nifti1Image(self.r2_map,
                                           affine=self.affine)
                nib.save(r2_nifti, f&#39;{base_path}_r2_map.nii.gz&#39;)
            elif result == &#39;mask&#39;:
                mask_nifti = nib.Nifti1Image(self.mask.astype(np.uint16),
                                             affine=self.affine)
                nib.save(mask_nifti, f&#39;{base_path}_mask.nii.gz&#39;)
    else:
        raise ValueError(&#39;No NIFTI file saved. The variable &#34;maps&#34; &#39;
                         &#39;should be &#34;all&#34; or a list of maps from &#39;
                         &#39;&#34;[&#34;t2&#34;, &#34;m0&#34;, &#34;b1&#34;, &#34;r2&#34;, &#39;
                         &#39;&#34;mask&#34;]&#34;.&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ukat.mapping" href="index.html">ukat.mapping</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ukat.mapping.t2_stimfit.StimFitModel" href="#ukat.mapping.t2_stimfit.StimFitModel">StimFitModel</a></code></h4>
<ul class="">
<li><code><a title="ukat.mapping.t2_stimfit.StimFitModel.get_lsq" href="#ukat.mapping.t2_stimfit.StimFitModel.get_lsq">get_lsq</a></code></li>
<li><code><a title="ukat.mapping.t2_stimfit.StimFitModel.get_opt" href="#ukat.mapping.t2_stimfit.StimFitModel.get_opt">get_opt</a></code></li>
<li><code><a title="ukat.mapping.t2_stimfit.StimFitModel.get_rfe" href="#ukat.mapping.t2_stimfit.StimFitModel.get_rfe">get_rfe</a></code></li>
<li><code><a title="ukat.mapping.t2_stimfit.StimFitModel.get_rfr" href="#ukat.mapping.t2_stimfit.StimFitModel.get_rfr">get_rfr</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ukat.mapping.t2_stimfit.T2StimFit" href="#ukat.mapping.t2_stimfit.T2StimFit">T2StimFit</a></code></h4>
<ul class="">
<li><code><a title="ukat.mapping.t2_stimfit.T2StimFit.get_fit_signal" href="#ukat.mapping.t2_stimfit.T2StimFit.get_fit_signal">get_fit_signal</a></code></li>
<li><code><a title="ukat.mapping.t2_stimfit.T2StimFit.to_nifti" href="#ukat.mapping.t2_stimfit.T2StimFit.to_nifti">to_nifti</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>