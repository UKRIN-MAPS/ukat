<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ukat.mapping.t1 API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ukat.mapping.t1</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import nibabel as nib
import numpy as np
import os
import warnings

from . import fitting


class T1Model(fitting.Model):
    def __init__(self, pixel_array, ti, parameters=2, mask=None, tss=0,
                 tss_axis=-2, multithread=True):
        &#34;&#34;&#34;
        A class containing the T1 fitting model

        Parameters
        ----------
        pixel_array : np.ndarray
            An array containing the signal from each voxel at each echo
            time with the last dimension being time i.e. the array needed to
            generate a 3D T1 map would have dimensions [x, y, z, TE].
        ti : np.ndarray
            An array of the inversion times used for the last dimension of the
            pixel_array. In milliseconds.
        parameters : {2, 3}, optional
            Default `2`
            The number of parameters to fit the data to. A two parameter fit
            will estimate S0 and T1 while a three parameter fit will also
            estimate the inversion efficiency.
        mask : np.ndarray, optional
            A boolean mask of the voxels to fit. Should be the shape of the
            desired T1 map rather than the raw data i.e. omit the time
            dimension.
        tss : float, optional
            Default 0
            The temporal slice spacing is the delay between acquisition of
            slices in a T1 map. Including this information means the
            inversion time is correct for each slice in a multi-slice T1
            map. In milliseconds.
        tss_axis : int, optional
            Default -2 i.e. last spatial axis
            The axis over which the temporal slice spacing is applied. This
            axis is relative to the full 4D pixel array i.e. tss_axis=-1
            would be along the TI axis and would be meaningless.
            If `pixel_array` is single slice (dimensions [x, y, TI]),
            then this should be set to None.
        multithread : bool, optional
            Default True
            If True, the fitting will be performed in parallel using all
            available cores
        &#34;&#34;&#34;
        self.parameters = parameters
        self.tss = tss
        self.tss_axis = tss_axis

        if np.min(pixel_array) &lt; 0:
            self.mag_corr = True
        else:
            self.mag_corr = False

        if self.parameters == 2:
            if self.mag_corr:
                super().__init__(pixel_array, ti, two_param_eq, mask,
                                 multithread)
            else:
                super().__init__(pixel_array, ti, two_param_abs_eq, mask,
                                 multithread)
            self.bounds = ([0, 0], [5000, 1000000000])
            self.initial_guess = [1000, 30000]
        elif self.parameters == 3:
            if self.mag_corr:
                super().__init__(pixel_array, ti, three_param_eq, mask,
                                 multithread)
            else:
                super().__init__(pixel_array, ti, three_param_abs_eq, mask,
                                 multithread)
            self.bounds = ([0, 0, 1], [5000, 1000000000, 2])
            self.initial_guess = [1000, 30000, 2]
        else:
            raise ValueError(f&#39;Parameters can be 2 or 3 only. You specified &#39;
                             f&#39;{parameters}.&#39;)

        self.generate_lists()
        if self.tss != 0:
            self._tss_correct_ti()

    def _tss_correct_ti(self):
        slices = np.indices(self.map_shape)[self.tss_axis].ravel()
        for ind, (ti, slice) in enumerate(zip(self.x_list, slices)):
            self.x_list[ind] = np.array(ti) + self.tss * slice


class T1:
    &#34;&#34;&#34;
    Attributes
    ----------
    t1_map : np.ndarray
        The estimated T1 values in ms
    t1_err : np.ndarray
        The certainty in the fit of `t1` in ms
    m0_map : np.ndarray
        The estimated M0 values
    m0_err : np.ndarray
        The certainty in the fit of `m0`
    eff_map : np.ndarray
        The estimated inversion efficiency where 0 represents no inversion
        pulse and 2 represents a 180 degree inversion
    eff_err : np.ndarray
        The certainty in the fit of `eff`
    r2 : np.ndarray
        The R-Squared value of the fit, values close to 1 indicate a good
        fit, lower values indicate a poorer fit
    shape : tuple
        The shape of the T1 map
    n_ti : int
        The number of TI used to calculate the map
    n_vox : int
        The number of voxels in the map i.e. the product of all dimensions
        apart from TI
    &#34;&#34;&#34;

    def __init__(self, pixel_array, inversion_list, affine, tss=0, tss_axis=-2,
                 mask=None, parameters=2, molli=False, multithread=True):
        &#34;&#34;&#34;Initialise a T1 class instance.

        Parameters
        ----------
        pixel_array : np.ndarray
            A array containing the signal from each voxel at each inversion
            time with the last dimension being time i.e. the array needed to
            generate a 3D T1 map would have dimensions [x, y, z, TI].
        inversion_list : list()
            An array of the inversion times used for the last dimension of the
            raw data. In milliseconds.
        tss : float, optional
            Default 0
            The temporal slice spacing is the delay between acquisition of
            slices in a T1 map. Including this information means the
            inversion time is correct for each slice in a multi-slice T1
            map. In milliseconds.
        tss_axis : int, optional
            Default -2 i.e. last spatial axis
            The axis over which the temporal slice spacing is applied. This
            axis is relative to the full 4D pixel array i.e. tss_axis=-1
            would be along the TI axis and would be meaningless.
            If `pixel_array` is single slice (dimensions [x, y, TI]),
            then this should be set to None.
        affine : np.ndarray
            A matrix giving the relationship between voxel coordinates and
            world coordinates.
        mask : np.ndarray, optional
            A boolean mask of the voxels to fit. Should be the shape of the
            desired T1 map rather than the raw data i.e. omit the time
            dimension.
        parameters : {2, 3}, optional
            Default `2`
            The number of parameters to fit the data to. A two parameter fit
            will estimate S0 and T1 while a three parameter fit will also
            estimate the inversion efficiency.
        molli : bool, optional
            Default False.
            Apply MOLLI corrections to T1.
        multithread : bool or &#39;auto&#39;, optional
            Default &#39;auto&#39;.
            If True, fitting will be distributed over all cores available on
            the node. If False, fitting will be carried out on a single thread.
            Multithreading is useful when calculating the T1 for a large
            number of voxels e.g. generating a multi-slice abdominal T1 map.
            Turning off multithreading can be useful when fitting very small
            amounts of data e.g. a mean T1 signal decay over a ROI when the
            overheads of multithreading are more of a hindrance than the
            increase in speed distributing the calculation would generate.
            &#39;auto&#39; attempts to apply multithreading where appropriate based
            on the number of voxels being fit.
        &#34;&#34;&#34;
        assert multithread is True \
               or multithread is False \
               or multithread == &#39;auto&#39;, f&#39;multithreaded must be True,&#39; \
                                         f&#39;False or auto. You entered &#39; \
                                         f&#39;{multithread}&#39;

        self.pixel_array = pixel_array
        self.shape = pixel_array.shape[:-1]
        self.dimensions = len(pixel_array.shape)
        self.n_ti = pixel_array.shape[-1]
        self.n_vox = np.prod(self.shape)
        self.affine = affine
        # Generate a mask if there isn&#39;t one specified
        if mask is None:
            self.mask = np.ones(self.shape, dtype=bool)
        else:
            self.mask = mask.astype(bool)
        # Don&#39;t process any nan values
        self.mask[np.isnan(np.sum(pixel_array, axis=-1))] = False
        self.inversion_list = inversion_list
        self.tss = tss
        if tss_axis is not None:
            self.tss_axis = tss_axis % self.dimensions
        else:
            self.tss_axis = None
            self.tss = 0
        self.parameters = parameters
        self.molli = molli
        if multithread == &#39;auto&#39;:
            if self.n_vox &gt; 20:
                multithread = True
            else:
                multithread = False
        self.multithread = multithread

        # Some sanity checks
        assert (pixel_array.shape[-1]
                == len(inversion_list)), &#39;Number of inversions does not &#39; \
                                         &#39;match the number of time frames &#39; \
                                         &#39;on the last axis of pixel_array&#39;
        if self.tss != 0:
            assert (self.tss_axis != self.dimensions - 1), \
                &#39;Temporal slice spacing can\&#39;t be applied to the TI axis.&#39;
            assert (tss_axis &lt; self.dimensions), \
                &#39;tss_axis must be less than the number of spatial dimensions&#39;
        if self.molli:
            if self.parameters == 2:
                self.parameters = 3
                warnings.warn(&#39;MOLLI requires a three parameter fit, &#39;
                              &#39;using parameters=3.&#39;)

        # Fit Data
        fitting_model = T1Model(self.pixel_array, self.inversion_list,
                                self.parameters, self.mask, self.tss,
                                self.tss_axis, self.multithread)
        popt, error, r2 = fitting.fit_image(fitting_model)
        self.t1_map = popt[0]
        self.m0_map = popt[1]
        self.t1_err = error[0]
        self.m0_err = error[1]
        self.r2 = r2

        if self.parameters == 3:
            self.eff_map = popt[2]
            self.eff_err = error[2]

        # Filter values that are very close to models upper bounds of T1 or
        # M0 out. Not filtering based on eff as this should ideally be at
        # the upper bound!
        threshold = 0.999  # 99.9% of the upper bound
        bounds_mask = ((self.t1_map &gt; fitting_model.bounds[1][0] * threshold) |
                       (self.m0_map &gt; fitting_model.bounds[1][1] * threshold))
        self.t1_map[bounds_mask] = 0
        self.m0_map[bounds_mask] = 0
        self.t1_err[bounds_mask] = 0
        self.m0_err[bounds_mask] = 0
        self.r2[bounds_mask] = 0
        if self.parameters == 3:
            self.eff_map[bounds_mask] = 0
            self.eff_err[bounds_mask] = 0

        # Do MOLLI correction
        if self.molli:
            correction_factor = (self.m0_map * self.eff_map) / self.m0_map - 1
            percentage_error = self.t1_err / self.t1_map
            self.t1_map = np.nan_to_num(self.t1_map * correction_factor)
            self.t1_err = np.nan_to_num(self.t1_map * percentage_error)

    def r1_map(self):
        &#34;&#34;&#34;
        Generates the R1 map from the T1 map output by initialising this
        class.

        Parameters
        ----------
        See class attributes in __init__

        Returns
        -------
        r1_map : np.ndarray
            An array containing the R1 map generated
            by the function with R1 measured in ms.
        &#34;&#34;&#34;
        with np.errstate(divide=&#39;ignore&#39;):
            r1_map = np.nan_to_num(np.reciprocal(self.t1_map), posinf=0,
                                   neginf=0)
        return r1_map

    def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;,
                 maps=&#39;all&#39;):
        &#34;&#34;&#34;Exports some of the T1 class attributes to NIFTI.

        Parameters
        ----------
        output_directory : string, optional
            Path to the folder where the NIFTI files will be saved.
        base_file_name : string, optional
            Filename of the resulting NIFTI. This code appends the extension.
            Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
        maps : list or &#39;all&#39;, optional
            List of maps to save to NIFTI. This should either the string &#34;all&#34;
            or a list of maps from [&#34;t1&#34;, &#34;t1_err&#34;, &#34;m0&#34;, &#34;m0_err&#34;, &#34;eff&#34;,
            &#34;eff_err&#34;, &#34;r1&#34;, &#34;r2&#34;, &#34;mask&#34;]
        &#34;&#34;&#34;
        os.makedirs(output_directory, exist_ok=True)
        base_path = os.path.join(output_directory, base_file_name)
        if maps == &#39;all&#39; or maps == [&#39;all&#39;]:
            maps = [&#39;t1&#39;, &#39;t1_err&#39;, &#39;m0&#39;, &#39;m0_err&#39;, &#39;eff&#39;, &#39;eff_err&#39;, &#39;r1_map&#39;,
                    &#39;r2&#39;, &#39;mask&#39;]
        if isinstance(maps, list):
            for result in maps:
                if result == &#39;t1&#39; or result == &#39;t1_map&#39;:
                    t1_nifti = nib.Nifti1Image(self.t1_map, affine=self.affine)
                    nib.save(t1_nifti, base_path + &#39;_t1_map.nii.gz&#39;)
                elif result == &#39;t1_err&#39;:
                    t1_err_nifti = nib.Nifti1Image(self.t1_err,
                                                   affine=self.affine)
                    nib.save(t1_err_nifti, base_path + &#39;_t1_err.nii.gz&#39;)
                elif result == &#39;m0&#39; or result == &#39;m0_map&#39;:
                    m0_nifti = nib.Nifti1Image(self.m0_map, affine=self.affine)
                    nib.save(m0_nifti, base_path + &#39;_m0_map.nii.gz&#39;)
                elif result == &#39;m0_err&#39;:
                    m0_err_nifti = nib.Nifti1Image(self.m0_err,
                                                   affine=self.affine)
                    nib.save(m0_err_nifti, base_path + &#39;_m0_err.nii.gz&#39;)
                elif (self.parameters == 3) and \
                     (result == &#39;eff&#39; or result == &#39;eff_map&#39;):
                    eff_nifti = nib.Nifti1Image(self.eff_map,
                                                affine=self.affine)
                    nib.save(eff_nifti, base_path + &#39;_eff_map.nii.gz&#39;)
                elif self.parameters == 3 and result == &#39;eff_err&#39;:
                    eff_err_nifti = nib.Nifti1Image(self.eff_err,
                                                    affine=self.affine)
                    nib.save(eff_err_nifti, base_path + &#39;_eff_err.nii.gz&#39;)
                elif result == &#39;r1&#39; or result == &#39;r1_map&#39;:
                    r1_nifti = nib.Nifti1Image(T1.r1_map(self),
                                               affine=self.affine)
                    nib.save(r1_nifti, base_path + &#39;_r1_map.nii.gz&#39;)
                elif result == &#39;r2&#39;:
                    r2_nifti = nib.Nifti1Image(self.r2,
                                               affine=self.affine)
                    nib.save(r2_nifti, base_path + &#39;_r2.nii.gz&#39;)
                elif result == &#39;mask&#39;:
                    mask_nifti = nib.Nifti1Image(self.mask.astype(np.uint16),
                                                 affine=self.affine)
                    nib.save(mask_nifti, base_path + &#39;_mask.nii.gz&#39;)
        else:
            raise ValueError(&#39;No NIFTI file saved. The variable &#34;maps&#34; &#39;
                             &#39;should be &#34;all&#34; or a list of maps from &#39;
                             &#39;&#34;[&#34;t1&#34;, &#34;t1_err&#34;, &#34;m0&#34;, &#34;m0_err&#34;, &#34;eff&#34;, &#39;
                             &#39;&#34;eff_err&#34;, &#34;r1&#34;, &#34;mask&#34;]&#34;.&#39;)

        return


def two_param_abs_eq(t, t1, m0):
    &#34;&#34;&#34;
    Calculate the expected signal from the equation signal = abs(M0 * (1 -
    2 * exp(-t / T1)))

    Parameters
    ----------
    t: list
        The times the signal will be calculated at
    t1: float
        The T1 of the signal
    m0: float
        The M0 of the signal

    Returns
    -------
    signal: ndarray
    &#34;&#34;&#34;
    with np.errstate(divide=&#39;ignore&#39;):
        signal = np.abs(m0 * (1 - 2 * np.exp(-t / t1)))
    return signal


def two_param_eq(t, t1, m0):
    &#34;&#34;&#34;
    Calculate the expected signal from the equation signal = M0 * (1 - 2 *
    exp(-t / T1))

    Parameters
    ----------
    t: list
        The times the signal will be calculated at
    t1: float
        The T1 of the signal
    m0: float
        The M0 of the signal

    Returns
    -------
    signal: ndarray
    &#34;&#34;&#34;
    with np.errstate(divide=&#39;ignore&#39;):
        signal = m0 * (1 - 2 * np.exp(-t / t1))
    return signal


def three_param_abs_eq(t, t1, m0, eff):
    &#34;&#34;&#34;
    Calculate the expected signal from the equation signal = abs(M0 * (1 -
    eff * exp(-t / T1)))

    Parameters
    ----------
    t: list
        The times the signal will be calculated at
    t1: float
        The T1 of the signal
    m0: float
        The M0 of the signal
    eff: float
        The inversion efficiency (where 0 is no inversion and 2 is a 180
        degree inversion)

    Returns
    -------
    signal: ndarray
    &#34;&#34;&#34;
    with np.errstate(divide=&#39;ignore&#39;):
        signal = np.abs(m0 * (1 - eff * np.exp(-t / t1)))
    return signal


def three_param_eq(t, t1, m0, eff):
    &#34;&#34;&#34;
    Calculate the expected signal from the equation signal = M0 * (1 - eff *
    exp(-t / T1)))

    Parameters
    ----------
    t: list
        The times the signal will be calculated at
    t1: float
        The T1 of the signal
    m0: float
        The M0 of the signal
    eff: float
        The inversion efficiency (where 0 is no inversion and 2 is a 180
        degree inversion)

    Returns
    -------
    signal: ndarray
    &#34;&#34;&#34;
    with np.errstate(divide=&#39;ignore&#39;):
        signal = m0 * (1 - eff * np.exp(-t / t1))
    return signal


def magnitude_correct(pixel_array):
    &#34;&#34;&#34;Sign corrects the magnitude of inversion recovery data using the
    complex component of the signal.

    This function uses the methods of Jerzy Szumowski et al
    (https://doi.org/10.1002/jmri.23705).

    Parameters
    ----------
    pixel_array: ndarray
        Can either be a complex array or have the real and imaginary
        parts of the image as the final dimension e.g. a complex 3D image
        could have the dimensions [x, y, z, ti] where [0, 0, 0, 0] = 1 + 2j
        or the dimensions [x, y, z, ti, type] where [0, 0, 0, 0, 0] = 1 and
        [0, 0, 0, 0, 1] = 2.

    Returns
    -------
    corrected_array : ndarray
        An array of the magnitude intensities with signs corrected.
    &#34;&#34;&#34;

    # Convert data to a complex array if it isn&#39;t already
    if not np.iscomplexobj(pixel_array):
        if pixel_array.shape[-1] == 2:
            pixel_array = pixel_array[..., 0] + pixel_array[..., 1] * (0 + 1j)
        else:
            raise ValueError(&#39;Last axis of pixel_array must have length 2&#39;)

    pixel_array_prime = np.zeros(pixel_array.shape, dtype=np.complex128)

    for ti in range(pixel_array.shape[-1]):
        pixel_array_prime[..., ti] = (pixel_array[..., ti] *
                                      pixel_array[..., -1].conjugate()) \
                                     / np.abs(pixel_array[..., -1])

    phase_factor = np.imag(np.log(pixel_array_prime / np.abs(pixel_array)))
    phase_offset = np.abs(phase_factor) - (np.pi / 2)
    sign = -(phase_offset / np.abs(phase_offset))
    corrected_array = sign * np.abs(pixel_array)
    return corrected_array</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ukat.mapping.t1.magnitude_correct"><code class="name flex">
<span>def <span class="ident">magnitude_correct</span></span>(<span>pixel_array)</span>
</code></dt>
<dd>
<div class="desc"><p>Sign corrects the magnitude of inversion recovery data using the
complex component of the signal.</p>
<p>This function uses the methods of Jerzy Szumowski et al
(<a href="https://doi.org/10.1002/jmri.23705">https://doi.org/10.1002/jmri.23705</a>).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pixel_array</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Can either be a complex array or have the real and imaginary
parts of the image as the final dimension e.g. a complex 3D image
could have the dimensions [x, y, z, ti] where [0, 0, 0, 0] = 1 + 2j
or the dimensions [x, y, z, ti, type] where [0, 0, 0, 0, 0] = 1 and
[0, 0, 0, 0, 1] = 2.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>corrected_array</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>An array of the magnitude intensities with signs corrected.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def magnitude_correct(pixel_array):
    &#34;&#34;&#34;Sign corrects the magnitude of inversion recovery data using the
    complex component of the signal.

    This function uses the methods of Jerzy Szumowski et al
    (https://doi.org/10.1002/jmri.23705).

    Parameters
    ----------
    pixel_array: ndarray
        Can either be a complex array or have the real and imaginary
        parts of the image as the final dimension e.g. a complex 3D image
        could have the dimensions [x, y, z, ti] where [0, 0, 0, 0] = 1 + 2j
        or the dimensions [x, y, z, ti, type] where [0, 0, 0, 0, 0] = 1 and
        [0, 0, 0, 0, 1] = 2.

    Returns
    -------
    corrected_array : ndarray
        An array of the magnitude intensities with signs corrected.
    &#34;&#34;&#34;

    # Convert data to a complex array if it isn&#39;t already
    if not np.iscomplexobj(pixel_array):
        if pixel_array.shape[-1] == 2:
            pixel_array = pixel_array[..., 0] + pixel_array[..., 1] * (0 + 1j)
        else:
            raise ValueError(&#39;Last axis of pixel_array must have length 2&#39;)

    pixel_array_prime = np.zeros(pixel_array.shape, dtype=np.complex128)

    for ti in range(pixel_array.shape[-1]):
        pixel_array_prime[..., ti] = (pixel_array[..., ti] *
                                      pixel_array[..., -1].conjugate()) \
                                     / np.abs(pixel_array[..., -1])

    phase_factor = np.imag(np.log(pixel_array_prime / np.abs(pixel_array)))
    phase_offset = np.abs(phase_factor) - (np.pi / 2)
    sign = -(phase_offset / np.abs(phase_offset))
    corrected_array = sign * np.abs(pixel_array)
    return corrected_array</code></pre>
</details>
</dd>
<dt id="ukat.mapping.t1.three_param_abs_eq"><code class="name flex">
<span>def <span class="ident">three_param_abs_eq</span></span>(<span>t, t1, m0, eff)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the expected signal from the equation signal = abs(M0 * (1 -
eff * exp(-t / T1)))</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>list</code></dt>
<dd>The times the signal will be calculated at</dd>
<dt><strong><code>t1</code></strong> :&ensp;<code>float</code></dt>
<dd>The T1 of the signal</dd>
<dt><strong><code>m0</code></strong> :&ensp;<code>float</code></dt>
<dd>The M0 of the signal</dd>
<dt><strong><code>eff</code></strong> :&ensp;<code>float</code></dt>
<dd>The inversion efficiency (where 0 is no inversion and 2 is a 180
degree inversion)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>signal</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def three_param_abs_eq(t, t1, m0, eff):
    &#34;&#34;&#34;
    Calculate the expected signal from the equation signal = abs(M0 * (1 -
    eff * exp(-t / T1)))

    Parameters
    ----------
    t: list
        The times the signal will be calculated at
    t1: float
        The T1 of the signal
    m0: float
        The M0 of the signal
    eff: float
        The inversion efficiency (where 0 is no inversion and 2 is a 180
        degree inversion)

    Returns
    -------
    signal: ndarray
    &#34;&#34;&#34;
    with np.errstate(divide=&#39;ignore&#39;):
        signal = np.abs(m0 * (1 - eff * np.exp(-t / t1)))
    return signal</code></pre>
</details>
</dd>
<dt id="ukat.mapping.t1.three_param_eq"><code class="name flex">
<span>def <span class="ident">three_param_eq</span></span>(<span>t, t1, m0, eff)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the expected signal from the equation signal = M0 * (1 - eff *
exp(-t / T1)))</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>list</code></dt>
<dd>The times the signal will be calculated at</dd>
<dt><strong><code>t1</code></strong> :&ensp;<code>float</code></dt>
<dd>The T1 of the signal</dd>
<dt><strong><code>m0</code></strong> :&ensp;<code>float</code></dt>
<dd>The M0 of the signal</dd>
<dt><strong><code>eff</code></strong> :&ensp;<code>float</code></dt>
<dd>The inversion efficiency (where 0 is no inversion and 2 is a 180
degree inversion)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>signal</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def three_param_eq(t, t1, m0, eff):
    &#34;&#34;&#34;
    Calculate the expected signal from the equation signal = M0 * (1 - eff *
    exp(-t / T1)))

    Parameters
    ----------
    t: list
        The times the signal will be calculated at
    t1: float
        The T1 of the signal
    m0: float
        The M0 of the signal
    eff: float
        The inversion efficiency (where 0 is no inversion and 2 is a 180
        degree inversion)

    Returns
    -------
    signal: ndarray
    &#34;&#34;&#34;
    with np.errstate(divide=&#39;ignore&#39;):
        signal = m0 * (1 - eff * np.exp(-t / t1))
    return signal</code></pre>
</details>
</dd>
<dt id="ukat.mapping.t1.two_param_abs_eq"><code class="name flex">
<span>def <span class="ident">two_param_abs_eq</span></span>(<span>t, t1, m0)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the expected signal from the equation signal = abs(M0 * (1 -
2 * exp(-t / T1)))</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>list</code></dt>
<dd>The times the signal will be calculated at</dd>
<dt><strong><code>t1</code></strong> :&ensp;<code>float</code></dt>
<dd>The T1 of the signal</dd>
<dt><strong><code>m0</code></strong> :&ensp;<code>float</code></dt>
<dd>The M0 of the signal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>signal</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def two_param_abs_eq(t, t1, m0):
    &#34;&#34;&#34;
    Calculate the expected signal from the equation signal = abs(M0 * (1 -
    2 * exp(-t / T1)))

    Parameters
    ----------
    t: list
        The times the signal will be calculated at
    t1: float
        The T1 of the signal
    m0: float
        The M0 of the signal

    Returns
    -------
    signal: ndarray
    &#34;&#34;&#34;
    with np.errstate(divide=&#39;ignore&#39;):
        signal = np.abs(m0 * (1 - 2 * np.exp(-t / t1)))
    return signal</code></pre>
</details>
</dd>
<dt id="ukat.mapping.t1.two_param_eq"><code class="name flex">
<span>def <span class="ident">two_param_eq</span></span>(<span>t, t1, m0)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the expected signal from the equation signal = M0 * (1 - 2 *
exp(-t / T1))</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>list</code></dt>
<dd>The times the signal will be calculated at</dd>
<dt><strong><code>t1</code></strong> :&ensp;<code>float</code></dt>
<dd>The T1 of the signal</dd>
<dt><strong><code>m0</code></strong> :&ensp;<code>float</code></dt>
<dd>The M0 of the signal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>signal</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def two_param_eq(t, t1, m0):
    &#34;&#34;&#34;
    Calculate the expected signal from the equation signal = M0 * (1 - 2 *
    exp(-t / T1))

    Parameters
    ----------
    t: list
        The times the signal will be calculated at
    t1: float
        The T1 of the signal
    m0: float
        The M0 of the signal

    Returns
    -------
    signal: ndarray
    &#34;&#34;&#34;
    with np.errstate(divide=&#39;ignore&#39;):
        signal = m0 * (1 - 2 * np.exp(-t / t1))
    return signal</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ukat.mapping.t1.T1"><code class="flex name class">
<span>class <span class="ident">T1</span></span>
<span>(</span><span>pixel_array, inversion_list, affine, tss=0, tss_axis=-2, mask=None, parameters=2, molli=False, multithread=True)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>t1_map</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The estimated T1 values in ms</dd>
<dt><strong><code>t1_err</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The certainty in the fit of <code>t1</code> in ms</dd>
<dt><strong><code>m0_map</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The estimated M0 values</dd>
<dt><strong><code>m0_err</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The certainty in the fit of <code>m0</code></dd>
<dt><strong><code>eff_map</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The estimated inversion efficiency where 0 represents no inversion
pulse and 2 represents a 180 degree inversion</dd>
<dt><strong><code>eff_err</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The certainty in the fit of <code>eff</code></dd>
<dt><strong><code>r2</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The R-Squared value of the fit, values close to 1 indicate a good
fit, lower values indicate a poorer fit</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The shape of the T1 map</dd>
<dt><strong><code>n_ti</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of TI used to calculate the map</dd>
<dt><strong><code>n_vox</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of voxels in the map i.e. the product of all dimensions
apart from TI</dd>
</dl>
<p>Initialise a T1 class instance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pixel_array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A array containing the signal from each voxel at each inversion
time with the last dimension being time i.e. the array needed to
generate a 3D T1 map would have dimensions [x, y, z, TI].</dd>
<dt><strong><code>inversion_list</code></strong> :&ensp;<code>list()</code></dt>
<dd>An array of the inversion times used for the last dimension of the
raw data. In milliseconds.</dd>
<dt><strong><code>tss</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Default 0
The temporal slice spacing is the delay between acquisition of
slices in a T1 map. Including this information means the
inversion time is correct for each slice in a multi-slice T1
map. In milliseconds.</dd>
<dt><strong><code>tss_axis</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Default -2 i.e. last spatial axis
The axis over which the temporal slice spacing is applied. This
axis is relative to the full 4D pixel array i.e. tss_axis=-1
would be along the TI axis and would be meaningless.
If <code>pixel_array</code> is single slice (dimensions [x, y, TI]),
then this should be set to None.</dd>
<dt><strong><code>affine</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A matrix giving the relationship between voxel coordinates and
world coordinates.</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>np.ndarray</code>, optional</dt>
<dd>A boolean mask of the voxels to fit. Should be the shape of the
desired T1 map rather than the raw data i.e. omit the time
dimension.</dd>
<dt><strong><code>parameters</code></strong> :&ensp;<code>{2, 3}</code>, optional</dt>
<dd>Default <code>2</code>
The number of parameters to fit the data to. A two parameter fit
will estimate S0 and T1 while a three parameter fit will also
estimate the inversion efficiency.</dd>
<dt><strong><code>molli</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Default False.
Apply MOLLI corrections to T1.</dd>
<dt><strong><code>multithread</code></strong> :&ensp;<code>bool</code> or <code>'auto'</code>, optional</dt>
<dd>Default 'auto'.
If True, fitting will be distributed over all cores available on
the node. If False, fitting will be carried out on a single thread.
Multithreading is useful when calculating the T1 for a large
number of voxels e.g. generating a multi-slice abdominal T1 map.
Turning off multithreading can be useful when fitting very small
amounts of data e.g. a mean T1 signal decay over a ROI when the
overheads of multithreading are more of a hindrance than the
increase in speed distributing the calculation would generate.
'auto' attempts to apply multithreading where appropriate based
on the number of voxels being fit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class T1:
    &#34;&#34;&#34;
    Attributes
    ----------
    t1_map : np.ndarray
        The estimated T1 values in ms
    t1_err : np.ndarray
        The certainty in the fit of `t1` in ms
    m0_map : np.ndarray
        The estimated M0 values
    m0_err : np.ndarray
        The certainty in the fit of `m0`
    eff_map : np.ndarray
        The estimated inversion efficiency where 0 represents no inversion
        pulse and 2 represents a 180 degree inversion
    eff_err : np.ndarray
        The certainty in the fit of `eff`
    r2 : np.ndarray
        The R-Squared value of the fit, values close to 1 indicate a good
        fit, lower values indicate a poorer fit
    shape : tuple
        The shape of the T1 map
    n_ti : int
        The number of TI used to calculate the map
    n_vox : int
        The number of voxels in the map i.e. the product of all dimensions
        apart from TI
    &#34;&#34;&#34;

    def __init__(self, pixel_array, inversion_list, affine, tss=0, tss_axis=-2,
                 mask=None, parameters=2, molli=False, multithread=True):
        &#34;&#34;&#34;Initialise a T1 class instance.

        Parameters
        ----------
        pixel_array : np.ndarray
            A array containing the signal from each voxel at each inversion
            time with the last dimension being time i.e. the array needed to
            generate a 3D T1 map would have dimensions [x, y, z, TI].
        inversion_list : list()
            An array of the inversion times used for the last dimension of the
            raw data. In milliseconds.
        tss : float, optional
            Default 0
            The temporal slice spacing is the delay between acquisition of
            slices in a T1 map. Including this information means the
            inversion time is correct for each slice in a multi-slice T1
            map. In milliseconds.
        tss_axis : int, optional
            Default -2 i.e. last spatial axis
            The axis over which the temporal slice spacing is applied. This
            axis is relative to the full 4D pixel array i.e. tss_axis=-1
            would be along the TI axis and would be meaningless.
            If `pixel_array` is single slice (dimensions [x, y, TI]),
            then this should be set to None.
        affine : np.ndarray
            A matrix giving the relationship between voxel coordinates and
            world coordinates.
        mask : np.ndarray, optional
            A boolean mask of the voxels to fit. Should be the shape of the
            desired T1 map rather than the raw data i.e. omit the time
            dimension.
        parameters : {2, 3}, optional
            Default `2`
            The number of parameters to fit the data to. A two parameter fit
            will estimate S0 and T1 while a three parameter fit will also
            estimate the inversion efficiency.
        molli : bool, optional
            Default False.
            Apply MOLLI corrections to T1.
        multithread : bool or &#39;auto&#39;, optional
            Default &#39;auto&#39;.
            If True, fitting will be distributed over all cores available on
            the node. If False, fitting will be carried out on a single thread.
            Multithreading is useful when calculating the T1 for a large
            number of voxels e.g. generating a multi-slice abdominal T1 map.
            Turning off multithreading can be useful when fitting very small
            amounts of data e.g. a mean T1 signal decay over a ROI when the
            overheads of multithreading are more of a hindrance than the
            increase in speed distributing the calculation would generate.
            &#39;auto&#39; attempts to apply multithreading where appropriate based
            on the number of voxels being fit.
        &#34;&#34;&#34;
        assert multithread is True \
               or multithread is False \
               or multithread == &#39;auto&#39;, f&#39;multithreaded must be True,&#39; \
                                         f&#39;False or auto. You entered &#39; \
                                         f&#39;{multithread}&#39;

        self.pixel_array = pixel_array
        self.shape = pixel_array.shape[:-1]
        self.dimensions = len(pixel_array.shape)
        self.n_ti = pixel_array.shape[-1]
        self.n_vox = np.prod(self.shape)
        self.affine = affine
        # Generate a mask if there isn&#39;t one specified
        if mask is None:
            self.mask = np.ones(self.shape, dtype=bool)
        else:
            self.mask = mask.astype(bool)
        # Don&#39;t process any nan values
        self.mask[np.isnan(np.sum(pixel_array, axis=-1))] = False
        self.inversion_list = inversion_list
        self.tss = tss
        if tss_axis is not None:
            self.tss_axis = tss_axis % self.dimensions
        else:
            self.tss_axis = None
            self.tss = 0
        self.parameters = parameters
        self.molli = molli
        if multithread == &#39;auto&#39;:
            if self.n_vox &gt; 20:
                multithread = True
            else:
                multithread = False
        self.multithread = multithread

        # Some sanity checks
        assert (pixel_array.shape[-1]
                == len(inversion_list)), &#39;Number of inversions does not &#39; \
                                         &#39;match the number of time frames &#39; \
                                         &#39;on the last axis of pixel_array&#39;
        if self.tss != 0:
            assert (self.tss_axis != self.dimensions - 1), \
                &#39;Temporal slice spacing can\&#39;t be applied to the TI axis.&#39;
            assert (tss_axis &lt; self.dimensions), \
                &#39;tss_axis must be less than the number of spatial dimensions&#39;
        if self.molli:
            if self.parameters == 2:
                self.parameters = 3
                warnings.warn(&#39;MOLLI requires a three parameter fit, &#39;
                              &#39;using parameters=3.&#39;)

        # Fit Data
        fitting_model = T1Model(self.pixel_array, self.inversion_list,
                                self.parameters, self.mask, self.tss,
                                self.tss_axis, self.multithread)
        popt, error, r2 = fitting.fit_image(fitting_model)
        self.t1_map = popt[0]
        self.m0_map = popt[1]
        self.t1_err = error[0]
        self.m0_err = error[1]
        self.r2 = r2

        if self.parameters == 3:
            self.eff_map = popt[2]
            self.eff_err = error[2]

        # Filter values that are very close to models upper bounds of T1 or
        # M0 out. Not filtering based on eff as this should ideally be at
        # the upper bound!
        threshold = 0.999  # 99.9% of the upper bound
        bounds_mask = ((self.t1_map &gt; fitting_model.bounds[1][0] * threshold) |
                       (self.m0_map &gt; fitting_model.bounds[1][1] * threshold))
        self.t1_map[bounds_mask] = 0
        self.m0_map[bounds_mask] = 0
        self.t1_err[bounds_mask] = 0
        self.m0_err[bounds_mask] = 0
        self.r2[bounds_mask] = 0
        if self.parameters == 3:
            self.eff_map[bounds_mask] = 0
            self.eff_err[bounds_mask] = 0

        # Do MOLLI correction
        if self.molli:
            correction_factor = (self.m0_map * self.eff_map) / self.m0_map - 1
            percentage_error = self.t1_err / self.t1_map
            self.t1_map = np.nan_to_num(self.t1_map * correction_factor)
            self.t1_err = np.nan_to_num(self.t1_map * percentage_error)

    def r1_map(self):
        &#34;&#34;&#34;
        Generates the R1 map from the T1 map output by initialising this
        class.

        Parameters
        ----------
        See class attributes in __init__

        Returns
        -------
        r1_map : np.ndarray
            An array containing the R1 map generated
            by the function with R1 measured in ms.
        &#34;&#34;&#34;
        with np.errstate(divide=&#39;ignore&#39;):
            r1_map = np.nan_to_num(np.reciprocal(self.t1_map), posinf=0,
                                   neginf=0)
        return r1_map

    def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;,
                 maps=&#39;all&#39;):
        &#34;&#34;&#34;Exports some of the T1 class attributes to NIFTI.

        Parameters
        ----------
        output_directory : string, optional
            Path to the folder where the NIFTI files will be saved.
        base_file_name : string, optional
            Filename of the resulting NIFTI. This code appends the extension.
            Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
        maps : list or &#39;all&#39;, optional
            List of maps to save to NIFTI. This should either the string &#34;all&#34;
            or a list of maps from [&#34;t1&#34;, &#34;t1_err&#34;, &#34;m0&#34;, &#34;m0_err&#34;, &#34;eff&#34;,
            &#34;eff_err&#34;, &#34;r1&#34;, &#34;r2&#34;, &#34;mask&#34;]
        &#34;&#34;&#34;
        os.makedirs(output_directory, exist_ok=True)
        base_path = os.path.join(output_directory, base_file_name)
        if maps == &#39;all&#39; or maps == [&#39;all&#39;]:
            maps = [&#39;t1&#39;, &#39;t1_err&#39;, &#39;m0&#39;, &#39;m0_err&#39;, &#39;eff&#39;, &#39;eff_err&#39;, &#39;r1_map&#39;,
                    &#39;r2&#39;, &#39;mask&#39;]
        if isinstance(maps, list):
            for result in maps:
                if result == &#39;t1&#39; or result == &#39;t1_map&#39;:
                    t1_nifti = nib.Nifti1Image(self.t1_map, affine=self.affine)
                    nib.save(t1_nifti, base_path + &#39;_t1_map.nii.gz&#39;)
                elif result == &#39;t1_err&#39;:
                    t1_err_nifti = nib.Nifti1Image(self.t1_err,
                                                   affine=self.affine)
                    nib.save(t1_err_nifti, base_path + &#39;_t1_err.nii.gz&#39;)
                elif result == &#39;m0&#39; or result == &#39;m0_map&#39;:
                    m0_nifti = nib.Nifti1Image(self.m0_map, affine=self.affine)
                    nib.save(m0_nifti, base_path + &#39;_m0_map.nii.gz&#39;)
                elif result == &#39;m0_err&#39;:
                    m0_err_nifti = nib.Nifti1Image(self.m0_err,
                                                   affine=self.affine)
                    nib.save(m0_err_nifti, base_path + &#39;_m0_err.nii.gz&#39;)
                elif (self.parameters == 3) and \
                     (result == &#39;eff&#39; or result == &#39;eff_map&#39;):
                    eff_nifti = nib.Nifti1Image(self.eff_map,
                                                affine=self.affine)
                    nib.save(eff_nifti, base_path + &#39;_eff_map.nii.gz&#39;)
                elif self.parameters == 3 and result == &#39;eff_err&#39;:
                    eff_err_nifti = nib.Nifti1Image(self.eff_err,
                                                    affine=self.affine)
                    nib.save(eff_err_nifti, base_path + &#39;_eff_err.nii.gz&#39;)
                elif result == &#39;r1&#39; or result == &#39;r1_map&#39;:
                    r1_nifti = nib.Nifti1Image(T1.r1_map(self),
                                               affine=self.affine)
                    nib.save(r1_nifti, base_path + &#39;_r1_map.nii.gz&#39;)
                elif result == &#39;r2&#39;:
                    r2_nifti = nib.Nifti1Image(self.r2,
                                               affine=self.affine)
                    nib.save(r2_nifti, base_path + &#39;_r2.nii.gz&#39;)
                elif result == &#39;mask&#39;:
                    mask_nifti = nib.Nifti1Image(self.mask.astype(np.uint16),
                                                 affine=self.affine)
                    nib.save(mask_nifti, base_path + &#39;_mask.nii.gz&#39;)
        else:
            raise ValueError(&#39;No NIFTI file saved. The variable &#34;maps&#34; &#39;
                             &#39;should be &#34;all&#34; or a list of maps from &#39;
                             &#39;&#34;[&#34;t1&#34;, &#34;t1_err&#34;, &#34;m0&#34;, &#34;m0_err&#34;, &#34;eff&#34;, &#39;
                             &#39;&#34;eff_err&#34;, &#34;r1&#34;, &#34;mask&#34;]&#34;.&#39;)

        return</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ukat.mapping.t1.T1.r1_map"><code class="name flex">
<span>def <span class="ident">r1_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the R1 map from the T1 map output by initialising this
class.</p>
<h2 id="parameters">Parameters</h2>
<p>See class attributes in <strong>init</strong></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>r1_map</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>An array containing the R1 map generated
by the function with R1 measured in ms.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def r1_map(self):
    &#34;&#34;&#34;
    Generates the R1 map from the T1 map output by initialising this
    class.

    Parameters
    ----------
    See class attributes in __init__

    Returns
    -------
    r1_map : np.ndarray
        An array containing the R1 map generated
        by the function with R1 measured in ms.
    &#34;&#34;&#34;
    with np.errstate(divide=&#39;ignore&#39;):
        r1_map = np.nan_to_num(np.reciprocal(self.t1_map), posinf=0,
                               neginf=0)
    return r1_map</code></pre>
</details>
</dd>
<dt id="ukat.mapping.t1.T1.to_nifti"><code class="name flex">
<span>def <span class="ident">to_nifti</span></span>(<span>self, output_directory='/home/runner/work/ukat/ukat', base_file_name='Output', maps='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Exports some of the T1 class attributes to NIFTI.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>output_directory</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Path to the folder where the NIFTI files will be saved.</dd>
<dt><strong><code>base_file_name</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Filename of the resulting NIFTI. This code appends the extension.
Eg., base_file_name = 'Output' will result in 'Output.nii.gz'.</dd>
<dt><strong><code>maps</code></strong> :&ensp;<code>list</code> or <code>'all'</code>, optional</dt>
<dd>List of maps to save to NIFTI. This should either the string "all"
or a list of maps from ["t1", "t1_err", "m0", "m0_err", "eff",
"eff_err", "r1", "r2", "mask"]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;,
             maps=&#39;all&#39;):
    &#34;&#34;&#34;Exports some of the T1 class attributes to NIFTI.

    Parameters
    ----------
    output_directory : string, optional
        Path to the folder where the NIFTI files will be saved.
    base_file_name : string, optional
        Filename of the resulting NIFTI. This code appends the extension.
        Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
    maps : list or &#39;all&#39;, optional
        List of maps to save to NIFTI. This should either the string &#34;all&#34;
        or a list of maps from [&#34;t1&#34;, &#34;t1_err&#34;, &#34;m0&#34;, &#34;m0_err&#34;, &#34;eff&#34;,
        &#34;eff_err&#34;, &#34;r1&#34;, &#34;r2&#34;, &#34;mask&#34;]
    &#34;&#34;&#34;
    os.makedirs(output_directory, exist_ok=True)
    base_path = os.path.join(output_directory, base_file_name)
    if maps == &#39;all&#39; or maps == [&#39;all&#39;]:
        maps = [&#39;t1&#39;, &#39;t1_err&#39;, &#39;m0&#39;, &#39;m0_err&#39;, &#39;eff&#39;, &#39;eff_err&#39;, &#39;r1_map&#39;,
                &#39;r2&#39;, &#39;mask&#39;]
    if isinstance(maps, list):
        for result in maps:
            if result == &#39;t1&#39; or result == &#39;t1_map&#39;:
                t1_nifti = nib.Nifti1Image(self.t1_map, affine=self.affine)
                nib.save(t1_nifti, base_path + &#39;_t1_map.nii.gz&#39;)
            elif result == &#39;t1_err&#39;:
                t1_err_nifti = nib.Nifti1Image(self.t1_err,
                                               affine=self.affine)
                nib.save(t1_err_nifti, base_path + &#39;_t1_err.nii.gz&#39;)
            elif result == &#39;m0&#39; or result == &#39;m0_map&#39;:
                m0_nifti = nib.Nifti1Image(self.m0_map, affine=self.affine)
                nib.save(m0_nifti, base_path + &#39;_m0_map.nii.gz&#39;)
            elif result == &#39;m0_err&#39;:
                m0_err_nifti = nib.Nifti1Image(self.m0_err,
                                               affine=self.affine)
                nib.save(m0_err_nifti, base_path + &#39;_m0_err.nii.gz&#39;)
            elif (self.parameters == 3) and \
                 (result == &#39;eff&#39; or result == &#39;eff_map&#39;):
                eff_nifti = nib.Nifti1Image(self.eff_map,
                                            affine=self.affine)
                nib.save(eff_nifti, base_path + &#39;_eff_map.nii.gz&#39;)
            elif self.parameters == 3 and result == &#39;eff_err&#39;:
                eff_err_nifti = nib.Nifti1Image(self.eff_err,
                                                affine=self.affine)
                nib.save(eff_err_nifti, base_path + &#39;_eff_err.nii.gz&#39;)
            elif result == &#39;r1&#39; or result == &#39;r1_map&#39;:
                r1_nifti = nib.Nifti1Image(T1.r1_map(self),
                                           affine=self.affine)
                nib.save(r1_nifti, base_path + &#39;_r1_map.nii.gz&#39;)
            elif result == &#39;r2&#39;:
                r2_nifti = nib.Nifti1Image(self.r2,
                                           affine=self.affine)
                nib.save(r2_nifti, base_path + &#39;_r2.nii.gz&#39;)
            elif result == &#39;mask&#39;:
                mask_nifti = nib.Nifti1Image(self.mask.astype(np.uint16),
                                             affine=self.affine)
                nib.save(mask_nifti, base_path + &#39;_mask.nii.gz&#39;)
    else:
        raise ValueError(&#39;No NIFTI file saved. The variable &#34;maps&#34; &#39;
                         &#39;should be &#34;all&#34; or a list of maps from &#39;
                         &#39;&#34;[&#34;t1&#34;, &#34;t1_err&#34;, &#34;m0&#34;, &#34;m0_err&#34;, &#34;eff&#34;, &#39;
                         &#39;&#34;eff_err&#34;, &#34;r1&#34;, &#34;mask&#34;]&#34;.&#39;)

    return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ukat.mapping.t1.T1Model"><code class="flex name class">
<span>class <span class="ident">T1Model</span></span>
<span>(</span><span>pixel_array, ti, parameters=2, mask=None, tss=0, tss_axis=-2, multithread=True)</span>
</code></dt>
<dd>
<div class="desc"><p>A class containing the T1 fitting model</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pixel_array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>An array containing the signal from each voxel at each echo
time with the last dimension being time i.e. the array needed to
generate a 3D T1 map would have dimensions [x, y, z, TE].</dd>
<dt><strong><code>ti</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>An array of the inversion times used for the last dimension of the
pixel_array. In milliseconds.</dd>
<dt><strong><code>parameters</code></strong> :&ensp;<code>{2, 3}</code>, optional</dt>
<dd>Default <code>2</code>
The number of parameters to fit the data to. A two parameter fit
will estimate S0 and T1 while a three parameter fit will also
estimate the inversion efficiency.</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>np.ndarray</code>, optional</dt>
<dd>A boolean mask of the voxels to fit. Should be the shape of the
desired T1 map rather than the raw data i.e. omit the time
dimension.</dd>
<dt><strong><code>tss</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Default 0
The temporal slice spacing is the delay between acquisition of
slices in a T1 map. Including this information means the
inversion time is correct for each slice in a multi-slice T1
map. In milliseconds.</dd>
<dt><strong><code>tss_axis</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Default -2 i.e. last spatial axis
The axis over which the temporal slice spacing is applied. This
axis is relative to the full 4D pixel array i.e. tss_axis=-1
would be along the TI axis and would be meaningless.
If <code>pixel_array</code> is single slice (dimensions [x, y, TI]),
then this should be set to None.</dd>
<dt><strong><code>multithread</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Default True
If True, the fitting will be performed in parallel using all
available cores</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class T1Model(fitting.Model):
    def __init__(self, pixel_array, ti, parameters=2, mask=None, tss=0,
                 tss_axis=-2, multithread=True):
        &#34;&#34;&#34;
        A class containing the T1 fitting model

        Parameters
        ----------
        pixel_array : np.ndarray
            An array containing the signal from each voxel at each echo
            time with the last dimension being time i.e. the array needed to
            generate a 3D T1 map would have dimensions [x, y, z, TE].
        ti : np.ndarray
            An array of the inversion times used for the last dimension of the
            pixel_array. In milliseconds.
        parameters : {2, 3}, optional
            Default `2`
            The number of parameters to fit the data to. A two parameter fit
            will estimate S0 and T1 while a three parameter fit will also
            estimate the inversion efficiency.
        mask : np.ndarray, optional
            A boolean mask of the voxels to fit. Should be the shape of the
            desired T1 map rather than the raw data i.e. omit the time
            dimension.
        tss : float, optional
            Default 0
            The temporal slice spacing is the delay between acquisition of
            slices in a T1 map. Including this information means the
            inversion time is correct for each slice in a multi-slice T1
            map. In milliseconds.
        tss_axis : int, optional
            Default -2 i.e. last spatial axis
            The axis over which the temporal slice spacing is applied. This
            axis is relative to the full 4D pixel array i.e. tss_axis=-1
            would be along the TI axis and would be meaningless.
            If `pixel_array` is single slice (dimensions [x, y, TI]),
            then this should be set to None.
        multithread : bool, optional
            Default True
            If True, the fitting will be performed in parallel using all
            available cores
        &#34;&#34;&#34;
        self.parameters = parameters
        self.tss = tss
        self.tss_axis = tss_axis

        if np.min(pixel_array) &lt; 0:
            self.mag_corr = True
        else:
            self.mag_corr = False

        if self.parameters == 2:
            if self.mag_corr:
                super().__init__(pixel_array, ti, two_param_eq, mask,
                                 multithread)
            else:
                super().__init__(pixel_array, ti, two_param_abs_eq, mask,
                                 multithread)
            self.bounds = ([0, 0], [5000, 1000000000])
            self.initial_guess = [1000, 30000]
        elif self.parameters == 3:
            if self.mag_corr:
                super().__init__(pixel_array, ti, three_param_eq, mask,
                                 multithread)
            else:
                super().__init__(pixel_array, ti, three_param_abs_eq, mask,
                                 multithread)
            self.bounds = ([0, 0, 1], [5000, 1000000000, 2])
            self.initial_guess = [1000, 30000, 2]
        else:
            raise ValueError(f&#39;Parameters can be 2 or 3 only. You specified &#39;
                             f&#39;{parameters}.&#39;)

        self.generate_lists()
        if self.tss != 0:
            self._tss_correct_ti()

    def _tss_correct_ti(self):
        slices = np.indices(self.map_shape)[self.tss_axis].ravel()
        for ind, (ti, slice) in enumerate(zip(self.x_list, slices)):
            self.x_list[ind] = np.array(ti) + self.tss * slice</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ukat.mapping.fitting.relaxation.Model" href="fitting/relaxation.html#ukat.mapping.fitting.relaxation.Model">Model</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ukat.mapping.fitting.relaxation.Model" href="fitting/relaxation.html#ukat.mapping.fitting.relaxation.Model">Model</a></b></code>:
<ul class="hlist">
<li><code><a title="ukat.mapping.fitting.relaxation.Model.generate_lists" href="fitting/relaxation.html#ukat.mapping.fitting.relaxation.Model.generate_lists">generate_lists</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ukat.mapping" href="index.html">ukat.mapping</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ukat.mapping.t1.magnitude_correct" href="#ukat.mapping.t1.magnitude_correct">magnitude_correct</a></code></li>
<li><code><a title="ukat.mapping.t1.three_param_abs_eq" href="#ukat.mapping.t1.three_param_abs_eq">three_param_abs_eq</a></code></li>
<li><code><a title="ukat.mapping.t1.three_param_eq" href="#ukat.mapping.t1.three_param_eq">three_param_eq</a></code></li>
<li><code><a title="ukat.mapping.t1.two_param_abs_eq" href="#ukat.mapping.t1.two_param_abs_eq">two_param_abs_eq</a></code></li>
<li><code><a title="ukat.mapping.t1.two_param_eq" href="#ukat.mapping.t1.two_param_eq">two_param_eq</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ukat.mapping.t1.T1" href="#ukat.mapping.t1.T1">T1</a></code></h4>
<ul class="">
<li><code><a title="ukat.mapping.t1.T1.r1_map" href="#ukat.mapping.t1.T1.r1_map">r1_map</a></code></li>
<li><code><a title="ukat.mapping.t1.T1.to_nifti" href="#ukat.mapping.t1.T1.to_nifti">to_nifti</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ukat.mapping.t1.T1Model" href="#ukat.mapping.t1.T1Model">T1Model</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>