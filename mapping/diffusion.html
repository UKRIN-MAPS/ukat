<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ukat.mapping.diffusion API documentation</title>
<meta name="description" content="Diffusion imaging module" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ukat.mapping.diffusion</code></h1>
</header>
<section id="section-intro">
<p>Diffusion imaging module</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Diffusion imaging module

&#34;&#34;&#34;
import os
import nibabel as nib
import numpy as np
import warnings

from dipy.core.gradients import gradient_table, unique_bvals_tolerance
from dipy.reconst.dti import TensorModel
from tqdm import tqdm


def make_gradient_scheme(bvals, bvecs, normalize=True, one_bzero=True):
    &#34;&#34;&#34;Make gradient scheme from list of bvals and bvecs

    Parameters
    ----------
    bvals : list
        b-values in s/mm2
    bvecs : list of lists
        bvectors (e.g. [[0, 0, 1], [1, 0, 0]])
    normalize : bool, optional (default True)
        Rescales bvecs to have unit length
    one_bzero : bool, optional (default True)
        Ensures gradient scheme only includes one b=0 measurement
        If this is True and bvals does not contain any b=0, a b=0 measurement
        will be included at the start of the acquisition

    Returns
    -------
    string
        gradient scheme with one line per measurement/volume as follows:
        bvec1_x   bvec1_y   bvec1_z   bval1
        bvec2_x   bvec2_y   bvec2_z   bval2
        ...
        bvecN_x   bvecN_y   bvecN_z   bvalN

    Notes
    -----
    This function was created to generate a diffusion scheme for the UKRIN-MAPS
    multishell acquisition where all the nonzero b-values have the same number
    of directions. Currently this does not provide features to generate
    schemes where different shells have different numbers of directions.
    This gradient scheme format was decided with the following in mind:
        1) can be easily written to a text file to allow modifications to it
           to be done without coding
        2) not vendor specific
        3) could be useful as a starting point to convert these schemes to
           vendor-specific formats

    &#34;&#34;&#34;
    if 0 not in bvals and one_bzero:
        bvals.insert(0, 0)

    if normalize:
        # Rescale bvecs to have norm 1
        bvecs = [v/np.linalg.norm(v) for v in bvecs]

    bvecs = [np.round(x, 8) for x in bvecs]

    # Make gradient scheme
    bzero_counter = 0
    gradient_scheme = &#34;&#34;
    for bvec in bvecs:
        for bval in bvals:
            if bval == 0 and one_bzero and bzero_counter &gt; 0:
                continue
            else:
                gradient_scheme = (f&#34;{gradient_scheme}&#34;
                                   f&#34;{str(bvec[0]).rjust(11)}  &#34;
                                   f&#34;{str(bvec[1]).rjust(11)}  &#34;
                                   f&#34;{str(bvec[2]).rjust(11)}  &#34;
                                   f&#34;{str(bval).rjust(5)}\n&#34;)
                if bval == 0:
                    bzero_counter += 1

    # Remove last newline
    if gradient_scheme[-1] == &#39;\n&#39;:
        gradient_scheme = gradient_scheme[:-1:]

    return gradient_scheme


class ADC:
    &#34;&#34;&#34;
    Attributes
    ----------
    adc : np.ndarray
        The estimated ADC in mm^2/s.
    adc_err : np.ndarray
        The certainty in the fit of `adc` in mm^2/s.
    shape : tuple
        The shape of the ADC map.
    n_vox : int
        The number of voxels in the map.
    bvals : 1d numpy array
        All b-values that will be used to generate the maps in s/mm^2.
    u_bvals : 1d numpy array
        The unique b-values used in the experiment e.g. if the experiment
        acquires a single b-0 volume and 64 volumes with b=600 s/mm^2 in
        different directions, u_bvals will be [0, 600].
    n_bvals : int
        The number of unique b-values acquired in the experiment.
    n_grad : int
        Total number of diffusion values/vectors acquired e.g. if the
        experiment acquires six directions at 10 gradient strengths and a
        b-0 volume, n_grad will be 61.
    pixel_array_mean : np.ndarray
        The average of the `pixel_array`across bvecs e.g. if `pixel_array`
        contains six volumes acquired with b=600 s/mm^2 in different
        directions, these six volumes will be averaged together.
    &#34;&#34;&#34;
    def __init__(self, pixel_array, affine, bvals, mask=None, ukrin_b=False):
        &#34;&#34;&#34;Initialise a ADC class instance.

        Parameters
        ----------
        pixel_array : (..., N) np.ndarray
            A array containing the signal from each voxel at each
            diffusion sensitising parameter. The final dimension should be
            different diffusion weightings/directions.
        affine : np.ndarray
            A matrix giving the relationship between voxel coordinates and
            world coordinates.
        bvals : (N,) np.array
            An array of the b-values used for the last dimension of the raw
            data. In s/mm^2.
        mask : np.ndarray, optional
            A boolean mask of the voxels to fit. Should be the shape of the
            desired map rather than the raw data i.e. omit the last dimension.
        ukrin_b : bool, optional
            If True, only b-values of 0, 100, 200 and 800 s/mm^2 will be
            included in the ADC fit. This aligns with Ljimani A, et al.
            Consensus-based technical recommendations for clinical translation
            of renal diffusion-weighted MRI.
            Magn Reson Mater Phy 2020;33:177–195
            doi: 10.1007/s10334-019-00790-y.
            If False, all b-values supplied will be used to fit ADC.
        &#34;&#34;&#34;
        ukrin_b_test = np.array([0, 100, 200, 800])
        # Sanity checks
        assert (pixel_array.shape[-1]
                == len(bvals)), &#39;Number of bvals does not match number of &#39; \
                                &#39;gradients in pixel_array&#39;

        if ukrin_b:
            self.b_mask = np.isin(bvals, ukrin_b_test)
        else:
            self.b_mask = np.full(len(bvals), True, dtype=bool)

        self.pixel_array = pixel_array[..., self.b_mask]
        self.shape = pixel_array.shape[:-1]
        self.n_vox = np.prod(self.shape)
        self.bvals = bvals[self.b_mask]
        self.n_grad = len(self.bvals)
        self.u_bvals = unique_bvals_tolerance(self.bvals, 1)
        self.n_bvals = len(self.u_bvals)
        self.affine = affine
        # Generate a mask if there isn&#39;t one specified
        if mask is None:
            self.mask = np.ones(self.shape, dtype=bool)
        else:
            self.mask = mask
            # Don&#39;t process any nan values
        self.mask[np.isnan(np.sum(pixel_array, axis=-1))] = False
        self.mask[np.sum(pixel_array &lt;= 0, axis=-1, dtype=bool)] = False
        self.pixel_array = np.nan_to_num(self.pixel_array)

        self.pixel_array_mean = self.__mean_over_directions__()

        self.adc, self.adc_err = self.__fit__()

    def __mean_over_directions__(self):
        &#34;&#34;&#34;
        Calculates the mean signal across different directions at each unique
        b-value e.g. if `pixel_array` contains six volumes acquired with
        b=600 s/mm^2 in different directions, these six volumes will be
        averaged together.

        Returns
        -------
        pixel_array_mean : np.ndarray
            The average of the `pixel_array` across bvecs
        &#34;&#34;&#34;
        pixel_array_mean = np.zeros((*self.shape, self.n_bvals))
        for ind, bval in enumerate(self.u_bvals):
            pixel_array_mean[..., ind]\
                = np.mean(self.pixel_array[..., self.bvals == bval], axis=-1)
        return pixel_array_mean

    def __fit__(self):
        # Initialise maps
        adc_map = np.zeros(self.n_vox)
        adc_err = np.zeros(self.n_vox)

        mask = self.mask.flatten()
        signal = self.pixel_array_mean.reshape(-1, self.n_bvals)
        idx = np.argwhere(mask).squeeze()
        with tqdm(total=idx.size) as progress:
            for ind in idx:
                sig = signal[ind, :]
                adc_map[ind], adc_err[ind] = \
                    self.__fit_signal__(sig, self.u_bvals)
                progress.update(1)
        adc_map[adc_map &lt; 0] = 0
        adc_err[adc_map &lt; 0] = 0

        # Reshape results into raw data shape
        adc_map = adc_map.reshape(self.shape)
        adc_err = adc_err.reshape(self.shape)

        return adc_map, adc_err

    @staticmethod
    def __fit_signal__(sig, bvals):
        try:
            popt, pvar = np.polyfit(bvals[sig &gt; 0], np.log(sig[sig &gt; 0]), 1,
                                    cov=True)
            adc = -popt[0]
            adc_err = np.sqrt(pvar[0, 0])
        except np.linalg.LinAlgError:
            adc = 0
            adc_err = 0

        return adc, adc_err

    def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;,
                 maps=&#39;all&#39;):
        &#34;&#34;&#34;Exports maps generated by the ADC class as NIFTI.

        Parameters
        ----------
        output_directory : string, optional
            Path to the folder where the NIFTI files will be saved.
        base_file_name : string, optional
            Filename of the resulting NIFTI. This code appends the extension.
            Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
        maps : list or &#39;all&#39;, optional
            List of maps to save to NIFTI. This should either the string &#34;all&#34;
            or a list of maps from [&#34;adc&#34;, &#34;adc_err&#34;, &#34;mask&#34;].
        &#34;&#34;&#34;
        os.makedirs(output_directory, exist_ok=True)
        base_path = os.path.join(output_directory, base_file_name)
        if maps == &#39;all&#39; or maps == [&#39;all&#39;]:
            maps = [&#39;adc&#39;, &#39;adc_err&#39;, &#39;mask&#39;]
        if isinstance(maps, list):
            for result in maps:
                if result == &#39;adc&#39; or result == &#39;adc_map&#39;:
                    adc_nifti = nib.Nifti1Image(self.adc, affine=self.affine)
                    nib.save(adc_nifti, base_path + &#39;_adc_map.nii.gz&#39;)
                elif result == &#39;adc_err&#39; or result == &#39;adc_err_map&#39;:
                    adc_err_nifti = nib.Nifti1Image(self.adc_err,
                                                    affine=self.affine)
                    nib.save(adc_err_nifti, base_path + &#39;_adc_err.nii.gz&#39;)
                elif result == &#39;mask&#39;:
                    mask_nifti = nib.Nifti1Image(self.mask.astype(np.uint16),
                                                 affine=self.affine)
                    nib.save(mask_nifti, base_path + &#39;_mask.nii.gz&#39;)
        else:
            raise ValueError(&#39;No NIFTI file saved. The variable &#34;maps&#34; &#39;
                             &#39;should be &#34;all&#34; or a list of maps from &#39;
                             &#39;&#34;[&#34;adc&#34;, &#34;adc_err&#34;, &#34;mask&#34;]&#34;.&#39;)


class DTI:
    &#34;&#34;&#34;
    Attributes
    ----------
    md : np.ndarray
        The estimated mean diffusivity values in mm^2/s.
    fa : np.ndarray
        The estimated fractional anisotropy values.
    color_fa : np.ndarray
        The estimated directional fractional anisotropy represented as red,
        green and blue corresponding to correspond to fractional anisotropy
        in the x, y and z directions respectively.
    shape : tuple
        The shape of the resulting maps
    bvals : 1d numpy array
        All b-values that will be used to generate the maps in s/mm^2.
    u_bvals : 1d numpy array
        The unique b-values used in the experiment e.g. if the experiment
        acquires a single b-0 volume and 64 volumes with b=600 s/mm^2 in
        different directions, u_bvals will be [0, 600].
    n_bvals : int
        The number of unique b-values acquired in the experiment.
    bvecs : (N, 3) numpy array
        All b-vectors that will be used to generate the maps.
    u_bvecs : (M, 3) numpy array
        The unique b-vectors used in the experiment e.g. if the experiment
        acquires six directions at 10 gradient strengths, u_bvecs will be a
        6 x 3 numpy array.
    n_bvecs : int
        The number of unique b-vectors acquired in the experiment.
    n_grad : int
        Total number of diffusion values/vectors acquired e.g. if the
        experiment acquires six directions at 10 gradient strengths and a
        b-0 volume, n_grad will be 61.
    gtab : dipy GradientTable
        The dipy gradient table used to generate maps.
    tensor_fit : dipy TensorModel after fitting
        The fit dipy tensor model, can be used to recall additional parameters.
    &#34;&#34;&#34;
    def __init__(self, pixel_array, affine, bvals, bvecs, mask=None,
                 ukrin_b=False):
        &#34;&#34;&#34;Initialise a DTI class instance.

        Parameters
        ----------
        pixel_array : (..., N) np.ndarray
            A array containing the signal from each voxel at each
            diffusion sensitising parameter. The final dimension should be
            different diffusion weightings/directions.
        affine : np.ndarray
            A matrix giving the relationship between voxel coordinates and
            world coordinates.
        bvals : (N,) np.array
            An array of the b-values used for the last dimension of the raw
            data. In s/mm^2.
        bvecs : (N, 3) np.array
            An array of the b-vectors used for the last dimension of the raw
            data. In s/mm^2.
        mask : np.ndarray, optional
            A boolean mask of the voxels to fit. Should be the shape of the
            desired map rather than the raw data i.e. omit the last dimension.
        ukrin_b : bool, optional
            If True, only b-values of 0, 100, 200 and 800 s/mm^2 will be
            included in the fit. This aligns with Ljimani A, et al.
            Consensus-based technical recommendations for clinical translation
            of renal diffusion-weighted MRI.
            Magn Reson Mater Phy 2020;33:177–195
            doi: 10.1007/s10334-019-00790-y.
            If False, all b-values supplied will be used.
        &#34;&#34;&#34;
        ukrin_b_test = np.array([0, 100, 200, 800])
        # Some sanity checks
        assert (pixel_array.shape[-1]
                == len(bvals)), &#39;Number of bvals does not match number of &#39; \
                                &#39;gradients in pixel_array&#39;
        if bvecs.shape[1] != 3 and bvecs.shape[0] == 3:
            bvecs = bvecs.T
            warnings.warn(f&#39;bvecs should be (N, 3). Because your bvecs array &#39;
                          &#39;is {bvecs.shape} it has been transposed to {&#39;
                          &#39;bvecs.T.shape}.&#39;)
        assert (bvecs.shape[1] == 3)
        assert (pixel_array.shape[-1] == bvecs.shape[0]), &#39;Number of bvecs &#39; \
                                                          &#39;does not match &#39; \
                                                          &#39;number of &#39; \
                                                          &#39;gradients in &#39; \
                                                          &#39;pixel_array&#39;
        if ukrin_b:
            self.b_mask = np.isin(bvals, ukrin_b_test)
        else:
            self.b_mask = np.full(len(bvals), True, dtype=bool)

        self.pixel_array = pixel_array[..., self.b_mask]
        self.shape = self.pixel_array.shape[:-1]
        self.bvals = bvals[self.b_mask]
        self.bvecs = bvecs[self.b_mask, :]
        self.n_grad = len(self.bvals)
        self.u_bvals = unique_bvals_tolerance(self.bvals, 1)
        self.n_bvals = len(self.u_bvals)
        self.u_bvecs = np.unique(self.bvecs, axis=0)
        self.n_bvecs = len(self.u_bvecs)
        self.affine = affine
        self.mask = mask
        self.gtab = gradient_table(self.bvals, self.bvecs, b0_threshold=0)
        tensor_model = TensorModel(self.gtab)
        self.tensor_fit = tensor_model.fit(self.pixel_array, mask=self.mask)
        self.md = self.tensor_fit.md
        self.fa = self.tensor_fit.fa
        self.color_fa = self.tensor_fit.color_fa

    def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;,
                 maps=&#39;all&#39;):
        &#34;&#34;&#34;Exports maps generated by the DTI class as NIFTI.

        Parameters
        ----------
        output_directory : string, optional
            Path to the folder where the NIFTI files will be saved.
        base_file_name : string, optional
            Filename of the resulting NIFTI. This code appends the extension.
            Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
        maps : list or &#39;all&#39;, optional
            List of maps to save to NIFTI. This should either the string &#34;all&#34;
            or a list of maps from [&#34;md&#34;, &#34;fa&#34;, &#34;color_fa&#34;, &#34;mask&#34;].
        &#34;&#34;&#34;
        os.makedirs(output_directory, exist_ok=True)
        base_path = os.path.join(output_directory, base_file_name)
        if maps == &#39;all&#39; or maps == [&#39;all&#39;]:
            maps = [&#39;md&#39;, &#39;fa&#39;, &#39;color_fa&#39;, &#39;mask&#39;]
        if isinstance(maps, list):
            for result in maps:
                if result == &#39;md&#39; or result == &#39;md_map&#39;:
                    md_nifti = nib.Nifti1Image(self.md, affine=self.affine)
                    nib.save(md_nifti, base_path + &#39;_md_map.nii.gz&#39;)
                elif result == &#39;fa&#39; or result == &#39;fa_map&#39;:
                    fa_nifti = nib.Nifti1Image(self.fa, affine=self.affine)
                    nib.save(fa_nifti, base_path + &#39;_fa_map.nii.gz&#39;)
                elif result == &#39;color_fa&#39; or result == &#39;color_fa_map&#39;:
                    color_fa_nifti = nib.Nifti1Image(self.color_fa,
                                                     affine=self.affine)
                    nib.save(color_fa_nifti, base_path +
                             &#39;_color_fa_map.nii.gz&#39;)
                elif result == &#39;mask&#39;:
                    mask_nifti = nib.Nifti1Image(self.mask.astype(np.uint16),
                                                 affine=self.affine)
                    nib.save(mask_nifti, base_path + &#39;_mask.nii.gz&#39;)
        else:
            raise ValueError(&#39;No NIFTI file saved. The variable &#34;maps&#34; &#39;
                             &#39;should be &#34;all&#34; or a list of maps from &#39;
                             &#39;&#34;[&#34;md&#34;, &#34;fa&#34;, &#34;color_fa&#34;, &#34;mask&#34;]&#34;.&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ukat.mapping.diffusion.make_gradient_scheme"><code class="name flex">
<span>def <span class="ident">make_gradient_scheme</span></span>(<span>bvals, bvecs, normalize=True, one_bzero=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Make gradient scheme from list of bvals and bvecs</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bvals</code></strong> :&ensp;<code>list</code></dt>
<dd>b-values in s/mm2</dd>
<dt><strong><code>bvecs</code></strong> :&ensp;<code>list</code> of <code>lists</code></dt>
<dd>bvectors (e.g. [[0, 0, 1], [1, 0, 0]])</dd>
<dt><strong><code>normalize</code></strong> :&ensp;<code>bool</code>, optional <code>(default True)</code></dt>
<dd>Rescales bvecs to have unit length</dd>
<dt><strong><code>one_bzero</code></strong> :&ensp;<code>bool</code>, optional <code>(default True)</code></dt>
<dd>Ensures gradient scheme only includes one b=0 measurement
If this is True and bvals does not contain any b=0, a b=0 measurement
will be included at the start of the acquisition</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>gradient scheme with one line per measurement/volume as follows:
bvec1_x
bvec1_y
bvec1_z
bval1
bvec2_x
bvec2_y
bvec2_z
bval2
&hellip;
bvecN_x
bvecN_y
bvecN_z
bvalN</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This function was created to generate a diffusion scheme for the UKRIN-MAPS
multishell acquisition where all the nonzero b-values have the same number
of directions. Currently this does not provide features to generate
schemes where different shells have different numbers of directions.
This gradient scheme format was decided with the following in mind:
1) can be easily written to a text file to allow modifications to it
to be done without coding
2) not vendor specific
3) could be useful as a starting point to convert these schemes to
vendor-specific formats</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_gradient_scheme(bvals, bvecs, normalize=True, one_bzero=True):
    &#34;&#34;&#34;Make gradient scheme from list of bvals and bvecs

    Parameters
    ----------
    bvals : list
        b-values in s/mm2
    bvecs : list of lists
        bvectors (e.g. [[0, 0, 1], [1, 0, 0]])
    normalize : bool, optional (default True)
        Rescales bvecs to have unit length
    one_bzero : bool, optional (default True)
        Ensures gradient scheme only includes one b=0 measurement
        If this is True and bvals does not contain any b=0, a b=0 measurement
        will be included at the start of the acquisition

    Returns
    -------
    string
        gradient scheme with one line per measurement/volume as follows:
        bvec1_x   bvec1_y   bvec1_z   bval1
        bvec2_x   bvec2_y   bvec2_z   bval2
        ...
        bvecN_x   bvecN_y   bvecN_z   bvalN

    Notes
    -----
    This function was created to generate a diffusion scheme for the UKRIN-MAPS
    multishell acquisition where all the nonzero b-values have the same number
    of directions. Currently this does not provide features to generate
    schemes where different shells have different numbers of directions.
    This gradient scheme format was decided with the following in mind:
        1) can be easily written to a text file to allow modifications to it
           to be done without coding
        2) not vendor specific
        3) could be useful as a starting point to convert these schemes to
           vendor-specific formats

    &#34;&#34;&#34;
    if 0 not in bvals and one_bzero:
        bvals.insert(0, 0)

    if normalize:
        # Rescale bvecs to have norm 1
        bvecs = [v/np.linalg.norm(v) for v in bvecs]

    bvecs = [np.round(x, 8) for x in bvecs]

    # Make gradient scheme
    bzero_counter = 0
    gradient_scheme = &#34;&#34;
    for bvec in bvecs:
        for bval in bvals:
            if bval == 0 and one_bzero and bzero_counter &gt; 0:
                continue
            else:
                gradient_scheme = (f&#34;{gradient_scheme}&#34;
                                   f&#34;{str(bvec[0]).rjust(11)}  &#34;
                                   f&#34;{str(bvec[1]).rjust(11)}  &#34;
                                   f&#34;{str(bvec[2]).rjust(11)}  &#34;
                                   f&#34;{str(bval).rjust(5)}\n&#34;)
                if bval == 0:
                    bzero_counter += 1

    # Remove last newline
    if gradient_scheme[-1] == &#39;\n&#39;:
        gradient_scheme = gradient_scheme[:-1:]

    return gradient_scheme</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ukat.mapping.diffusion.ADC"><code class="flex name class">
<span>class <span class="ident">ADC</span></span>
<span>(</span><span>pixel_array, affine, bvals, mask=None, ukrin_b=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>adc</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The estimated ADC in mm^2/s.</dd>
<dt><strong><code>adc_err</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The certainty in the fit of <code>adc</code> in mm^2/s.</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The shape of the ADC map.</dd>
<dt><strong><code>n_vox</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of voxels in the map.</dd>
<dt><strong><code>bvals</code></strong> :&ensp;<code>1d numpy array</code></dt>
<dd>All b-values that will be used to generate the maps in s/mm^2.</dd>
<dt><strong><code>u_bvals</code></strong> :&ensp;<code>1d numpy array</code></dt>
<dd>The unique b-values used in the experiment e.g. if the experiment
acquires a single b-0 volume and 64 volumes with b=600 s/mm^2 in
different directions, u_bvals will be [0, 600].</dd>
<dt><strong><code>n_bvals</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of unique b-values acquired in the experiment.</dd>
<dt><strong><code>n_grad</code></strong> :&ensp;<code>int</code></dt>
<dd>Total number of diffusion values/vectors acquired e.g. if the
experiment acquires six directions at 10 gradient strengths and a
b-0 volume, n_grad will be 61.</dd>
<dt><strong><code>pixel_array_mean</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The average of the <code>pixel_array</code>across bvecs e.g. if <code>pixel_array</code>
contains six volumes acquired with b=600 s/mm^2 in different
directions, these six volumes will be averaged together.</dd>
</dl>
<p>Initialise a ADC class instance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pixel_array</code></strong> :&ensp;<code>(&hellip;, N) np.ndarray</code></dt>
<dd>A array containing the signal from each voxel at each
diffusion sensitising parameter. The final dimension should be
different diffusion weightings/directions.</dd>
<dt><strong><code>affine</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A matrix giving the relationship between voxel coordinates and
world coordinates.</dd>
<dt><strong><code>bvals</code></strong> :&ensp;<code>(N,) np.array</code></dt>
<dd>An array of the b-values used for the last dimension of the raw
data. In s/mm^2.</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>np.ndarray</code>, optional</dt>
<dd>A boolean mask of the voxels to fit. Should be the shape of the
desired map rather than the raw data i.e. omit the last dimension.</dd>
<dt><strong><code>ukrin_b</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, only b-values of 0, 100, 200 and 800 s/mm^2 will be
included in the ADC fit. This aligns with Ljimani A, et al.
Consensus-based technical recommendations for clinical translation
of renal diffusion-weighted MRI.
Magn Reson Mater Phy 2020;33:177–195
doi: 10.1007/s10334-019-00790-y.
If False, all b-values supplied will be used to fit ADC.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ADC:
    &#34;&#34;&#34;
    Attributes
    ----------
    adc : np.ndarray
        The estimated ADC in mm^2/s.
    adc_err : np.ndarray
        The certainty in the fit of `adc` in mm^2/s.
    shape : tuple
        The shape of the ADC map.
    n_vox : int
        The number of voxels in the map.
    bvals : 1d numpy array
        All b-values that will be used to generate the maps in s/mm^2.
    u_bvals : 1d numpy array
        The unique b-values used in the experiment e.g. if the experiment
        acquires a single b-0 volume and 64 volumes with b=600 s/mm^2 in
        different directions, u_bvals will be [0, 600].
    n_bvals : int
        The number of unique b-values acquired in the experiment.
    n_grad : int
        Total number of diffusion values/vectors acquired e.g. if the
        experiment acquires six directions at 10 gradient strengths and a
        b-0 volume, n_grad will be 61.
    pixel_array_mean : np.ndarray
        The average of the `pixel_array`across bvecs e.g. if `pixel_array`
        contains six volumes acquired with b=600 s/mm^2 in different
        directions, these six volumes will be averaged together.
    &#34;&#34;&#34;
    def __init__(self, pixel_array, affine, bvals, mask=None, ukrin_b=False):
        &#34;&#34;&#34;Initialise a ADC class instance.

        Parameters
        ----------
        pixel_array : (..., N) np.ndarray
            A array containing the signal from each voxel at each
            diffusion sensitising parameter. The final dimension should be
            different diffusion weightings/directions.
        affine : np.ndarray
            A matrix giving the relationship between voxel coordinates and
            world coordinates.
        bvals : (N,) np.array
            An array of the b-values used for the last dimension of the raw
            data. In s/mm^2.
        mask : np.ndarray, optional
            A boolean mask of the voxels to fit. Should be the shape of the
            desired map rather than the raw data i.e. omit the last dimension.
        ukrin_b : bool, optional
            If True, only b-values of 0, 100, 200 and 800 s/mm^2 will be
            included in the ADC fit. This aligns with Ljimani A, et al.
            Consensus-based technical recommendations for clinical translation
            of renal diffusion-weighted MRI.
            Magn Reson Mater Phy 2020;33:177–195
            doi: 10.1007/s10334-019-00790-y.
            If False, all b-values supplied will be used to fit ADC.
        &#34;&#34;&#34;
        ukrin_b_test = np.array([0, 100, 200, 800])
        # Sanity checks
        assert (pixel_array.shape[-1]
                == len(bvals)), &#39;Number of bvals does not match number of &#39; \
                                &#39;gradients in pixel_array&#39;

        if ukrin_b:
            self.b_mask = np.isin(bvals, ukrin_b_test)
        else:
            self.b_mask = np.full(len(bvals), True, dtype=bool)

        self.pixel_array = pixel_array[..., self.b_mask]
        self.shape = pixel_array.shape[:-1]
        self.n_vox = np.prod(self.shape)
        self.bvals = bvals[self.b_mask]
        self.n_grad = len(self.bvals)
        self.u_bvals = unique_bvals_tolerance(self.bvals, 1)
        self.n_bvals = len(self.u_bvals)
        self.affine = affine
        # Generate a mask if there isn&#39;t one specified
        if mask is None:
            self.mask = np.ones(self.shape, dtype=bool)
        else:
            self.mask = mask
            # Don&#39;t process any nan values
        self.mask[np.isnan(np.sum(pixel_array, axis=-1))] = False
        self.mask[np.sum(pixel_array &lt;= 0, axis=-1, dtype=bool)] = False
        self.pixel_array = np.nan_to_num(self.pixel_array)

        self.pixel_array_mean = self.__mean_over_directions__()

        self.adc, self.adc_err = self.__fit__()

    def __mean_over_directions__(self):
        &#34;&#34;&#34;
        Calculates the mean signal across different directions at each unique
        b-value e.g. if `pixel_array` contains six volumes acquired with
        b=600 s/mm^2 in different directions, these six volumes will be
        averaged together.

        Returns
        -------
        pixel_array_mean : np.ndarray
            The average of the `pixel_array` across bvecs
        &#34;&#34;&#34;
        pixel_array_mean = np.zeros((*self.shape, self.n_bvals))
        for ind, bval in enumerate(self.u_bvals):
            pixel_array_mean[..., ind]\
                = np.mean(self.pixel_array[..., self.bvals == bval], axis=-1)
        return pixel_array_mean

    def __fit__(self):
        # Initialise maps
        adc_map = np.zeros(self.n_vox)
        adc_err = np.zeros(self.n_vox)

        mask = self.mask.flatten()
        signal = self.pixel_array_mean.reshape(-1, self.n_bvals)
        idx = np.argwhere(mask).squeeze()
        with tqdm(total=idx.size) as progress:
            for ind in idx:
                sig = signal[ind, :]
                adc_map[ind], adc_err[ind] = \
                    self.__fit_signal__(sig, self.u_bvals)
                progress.update(1)
        adc_map[adc_map &lt; 0] = 0
        adc_err[adc_map &lt; 0] = 0

        # Reshape results into raw data shape
        adc_map = adc_map.reshape(self.shape)
        adc_err = adc_err.reshape(self.shape)

        return adc_map, adc_err

    @staticmethod
    def __fit_signal__(sig, bvals):
        try:
            popt, pvar = np.polyfit(bvals[sig &gt; 0], np.log(sig[sig &gt; 0]), 1,
                                    cov=True)
            adc = -popt[0]
            adc_err = np.sqrt(pvar[0, 0])
        except np.linalg.LinAlgError:
            adc = 0
            adc_err = 0

        return adc, adc_err

    def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;,
                 maps=&#39;all&#39;):
        &#34;&#34;&#34;Exports maps generated by the ADC class as NIFTI.

        Parameters
        ----------
        output_directory : string, optional
            Path to the folder where the NIFTI files will be saved.
        base_file_name : string, optional
            Filename of the resulting NIFTI. This code appends the extension.
            Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
        maps : list or &#39;all&#39;, optional
            List of maps to save to NIFTI. This should either the string &#34;all&#34;
            or a list of maps from [&#34;adc&#34;, &#34;adc_err&#34;, &#34;mask&#34;].
        &#34;&#34;&#34;
        os.makedirs(output_directory, exist_ok=True)
        base_path = os.path.join(output_directory, base_file_name)
        if maps == &#39;all&#39; or maps == [&#39;all&#39;]:
            maps = [&#39;adc&#39;, &#39;adc_err&#39;, &#39;mask&#39;]
        if isinstance(maps, list):
            for result in maps:
                if result == &#39;adc&#39; or result == &#39;adc_map&#39;:
                    adc_nifti = nib.Nifti1Image(self.adc, affine=self.affine)
                    nib.save(adc_nifti, base_path + &#39;_adc_map.nii.gz&#39;)
                elif result == &#39;adc_err&#39; or result == &#39;adc_err_map&#39;:
                    adc_err_nifti = nib.Nifti1Image(self.adc_err,
                                                    affine=self.affine)
                    nib.save(adc_err_nifti, base_path + &#39;_adc_err.nii.gz&#39;)
                elif result == &#39;mask&#39;:
                    mask_nifti = nib.Nifti1Image(self.mask.astype(np.uint16),
                                                 affine=self.affine)
                    nib.save(mask_nifti, base_path + &#39;_mask.nii.gz&#39;)
        else:
            raise ValueError(&#39;No NIFTI file saved. The variable &#34;maps&#34; &#39;
                             &#39;should be &#34;all&#34; or a list of maps from &#39;
                             &#39;&#34;[&#34;adc&#34;, &#34;adc_err&#34;, &#34;mask&#34;]&#34;.&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ukat.mapping.diffusion.ADC.to_nifti"><code class="name flex">
<span>def <span class="ident">to_nifti</span></span>(<span>self, output_directory='/home/runner/work/ukat/ukat', base_file_name='Output', maps='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Exports maps generated by the ADC class as NIFTI.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>output_directory</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Path to the folder where the NIFTI files will be saved.</dd>
<dt><strong><code>base_file_name</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Filename of the resulting NIFTI. This code appends the extension.
Eg., base_file_name = 'Output' will result in 'Output.nii.gz'.</dd>
<dt><strong><code>maps</code></strong> :&ensp;<code>list</code> or <code>'all'</code>, optional</dt>
<dd>List of maps to save to NIFTI. This should either the string "all"
or a list of maps from ["adc", "adc_err", "mask"].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;,
             maps=&#39;all&#39;):
    &#34;&#34;&#34;Exports maps generated by the ADC class as NIFTI.

    Parameters
    ----------
    output_directory : string, optional
        Path to the folder where the NIFTI files will be saved.
    base_file_name : string, optional
        Filename of the resulting NIFTI. This code appends the extension.
        Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
    maps : list or &#39;all&#39;, optional
        List of maps to save to NIFTI. This should either the string &#34;all&#34;
        or a list of maps from [&#34;adc&#34;, &#34;adc_err&#34;, &#34;mask&#34;].
    &#34;&#34;&#34;
    os.makedirs(output_directory, exist_ok=True)
    base_path = os.path.join(output_directory, base_file_name)
    if maps == &#39;all&#39; or maps == [&#39;all&#39;]:
        maps = [&#39;adc&#39;, &#39;adc_err&#39;, &#39;mask&#39;]
    if isinstance(maps, list):
        for result in maps:
            if result == &#39;adc&#39; or result == &#39;adc_map&#39;:
                adc_nifti = nib.Nifti1Image(self.adc, affine=self.affine)
                nib.save(adc_nifti, base_path + &#39;_adc_map.nii.gz&#39;)
            elif result == &#39;adc_err&#39; or result == &#39;adc_err_map&#39;:
                adc_err_nifti = nib.Nifti1Image(self.adc_err,
                                                affine=self.affine)
                nib.save(adc_err_nifti, base_path + &#39;_adc_err.nii.gz&#39;)
            elif result == &#39;mask&#39;:
                mask_nifti = nib.Nifti1Image(self.mask.astype(np.uint16),
                                             affine=self.affine)
                nib.save(mask_nifti, base_path + &#39;_mask.nii.gz&#39;)
    else:
        raise ValueError(&#39;No NIFTI file saved. The variable &#34;maps&#34; &#39;
                         &#39;should be &#34;all&#34; or a list of maps from &#39;
                         &#39;&#34;[&#34;adc&#34;, &#34;adc_err&#34;, &#34;mask&#34;]&#34;.&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ukat.mapping.diffusion.DTI"><code class="flex name class">
<span>class <span class="ident">DTI</span></span>
<span>(</span><span>pixel_array, affine, bvals, bvecs, mask=None, ukrin_b=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>md</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The estimated mean diffusivity values in mm^2/s.</dd>
<dt><strong><code>fa</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The estimated fractional anisotropy values.</dd>
<dt><strong><code>color_fa</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The estimated directional fractional anisotropy represented as red,
green and blue corresponding to correspond to fractional anisotropy
in the x, y and z directions respectively.</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The shape of the resulting maps</dd>
<dt><strong><code>bvals</code></strong> :&ensp;<code>1d numpy array</code></dt>
<dd>All b-values that will be used to generate the maps in s/mm^2.</dd>
<dt><strong><code>u_bvals</code></strong> :&ensp;<code>1d numpy array</code></dt>
<dd>The unique b-values used in the experiment e.g. if the experiment
acquires a single b-0 volume and 64 volumes with b=600 s/mm^2 in
different directions, u_bvals will be [0, 600].</dd>
<dt><strong><code>n_bvals</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of unique b-values acquired in the experiment.</dd>
<dt><strong><code>bvecs</code></strong> :&ensp;<code>(N, 3) numpy array</code></dt>
<dd>All b-vectors that will be used to generate the maps.</dd>
<dt><strong><code>u_bvecs</code></strong> :&ensp;<code>(M, 3) numpy array</code></dt>
<dd>The unique b-vectors used in the experiment e.g. if the experiment
acquires six directions at 10 gradient strengths, u_bvecs will be a
6 x 3 numpy array.</dd>
<dt><strong><code>n_bvecs</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of unique b-vectors acquired in the experiment.</dd>
<dt><strong><code>n_grad</code></strong> :&ensp;<code>int</code></dt>
<dd>Total number of diffusion values/vectors acquired e.g. if the
experiment acquires six directions at 10 gradient strengths and a
b-0 volume, n_grad will be 61.</dd>
<dt><strong><code>gtab</code></strong> :&ensp;<code>dipy GradientTable</code></dt>
<dd>The dipy gradient table used to generate maps.</dd>
<dt><strong><code>tensor_fit</code></strong> :&ensp;<code>dipy TensorModel after fitting</code></dt>
<dd>The fit dipy tensor model, can be used to recall additional parameters.</dd>
</dl>
<p>Initialise a DTI class instance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pixel_array</code></strong> :&ensp;<code>(&hellip;, N) np.ndarray</code></dt>
<dd>A array containing the signal from each voxel at each
diffusion sensitising parameter. The final dimension should be
different diffusion weightings/directions.</dd>
<dt><strong><code>affine</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A matrix giving the relationship between voxel coordinates and
world coordinates.</dd>
<dt><strong><code>bvals</code></strong> :&ensp;<code>(N,) np.array</code></dt>
<dd>An array of the b-values used for the last dimension of the raw
data. In s/mm^2.</dd>
<dt><strong><code>bvecs</code></strong> :&ensp;<code>(N, 3) np.array</code></dt>
<dd>An array of the b-vectors used for the last dimension of the raw
data. In s/mm^2.</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>np.ndarray</code>, optional</dt>
<dd>A boolean mask of the voxels to fit. Should be the shape of the
desired map rather than the raw data i.e. omit the last dimension.</dd>
<dt><strong><code>ukrin_b</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, only b-values of 0, 100, 200 and 800 s/mm^2 will be
included in the fit. This aligns with Ljimani A, et al.
Consensus-based technical recommendations for clinical translation
of renal diffusion-weighted MRI.
Magn Reson Mater Phy 2020;33:177–195
doi: 10.1007/s10334-019-00790-y.
If False, all b-values supplied will be used.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DTI:
    &#34;&#34;&#34;
    Attributes
    ----------
    md : np.ndarray
        The estimated mean diffusivity values in mm^2/s.
    fa : np.ndarray
        The estimated fractional anisotropy values.
    color_fa : np.ndarray
        The estimated directional fractional anisotropy represented as red,
        green and blue corresponding to correspond to fractional anisotropy
        in the x, y and z directions respectively.
    shape : tuple
        The shape of the resulting maps
    bvals : 1d numpy array
        All b-values that will be used to generate the maps in s/mm^2.
    u_bvals : 1d numpy array
        The unique b-values used in the experiment e.g. if the experiment
        acquires a single b-0 volume and 64 volumes with b=600 s/mm^2 in
        different directions, u_bvals will be [0, 600].
    n_bvals : int
        The number of unique b-values acquired in the experiment.
    bvecs : (N, 3) numpy array
        All b-vectors that will be used to generate the maps.
    u_bvecs : (M, 3) numpy array
        The unique b-vectors used in the experiment e.g. if the experiment
        acquires six directions at 10 gradient strengths, u_bvecs will be a
        6 x 3 numpy array.
    n_bvecs : int
        The number of unique b-vectors acquired in the experiment.
    n_grad : int
        Total number of diffusion values/vectors acquired e.g. if the
        experiment acquires six directions at 10 gradient strengths and a
        b-0 volume, n_grad will be 61.
    gtab : dipy GradientTable
        The dipy gradient table used to generate maps.
    tensor_fit : dipy TensorModel after fitting
        The fit dipy tensor model, can be used to recall additional parameters.
    &#34;&#34;&#34;
    def __init__(self, pixel_array, affine, bvals, bvecs, mask=None,
                 ukrin_b=False):
        &#34;&#34;&#34;Initialise a DTI class instance.

        Parameters
        ----------
        pixel_array : (..., N) np.ndarray
            A array containing the signal from each voxel at each
            diffusion sensitising parameter. The final dimension should be
            different diffusion weightings/directions.
        affine : np.ndarray
            A matrix giving the relationship between voxel coordinates and
            world coordinates.
        bvals : (N,) np.array
            An array of the b-values used for the last dimension of the raw
            data. In s/mm^2.
        bvecs : (N, 3) np.array
            An array of the b-vectors used for the last dimension of the raw
            data. In s/mm^2.
        mask : np.ndarray, optional
            A boolean mask of the voxels to fit. Should be the shape of the
            desired map rather than the raw data i.e. omit the last dimension.
        ukrin_b : bool, optional
            If True, only b-values of 0, 100, 200 and 800 s/mm^2 will be
            included in the fit. This aligns with Ljimani A, et al.
            Consensus-based technical recommendations for clinical translation
            of renal diffusion-weighted MRI.
            Magn Reson Mater Phy 2020;33:177–195
            doi: 10.1007/s10334-019-00790-y.
            If False, all b-values supplied will be used.
        &#34;&#34;&#34;
        ukrin_b_test = np.array([0, 100, 200, 800])
        # Some sanity checks
        assert (pixel_array.shape[-1]
                == len(bvals)), &#39;Number of bvals does not match number of &#39; \
                                &#39;gradients in pixel_array&#39;
        if bvecs.shape[1] != 3 and bvecs.shape[0] == 3:
            bvecs = bvecs.T
            warnings.warn(f&#39;bvecs should be (N, 3). Because your bvecs array &#39;
                          &#39;is {bvecs.shape} it has been transposed to {&#39;
                          &#39;bvecs.T.shape}.&#39;)
        assert (bvecs.shape[1] == 3)
        assert (pixel_array.shape[-1] == bvecs.shape[0]), &#39;Number of bvecs &#39; \
                                                          &#39;does not match &#39; \
                                                          &#39;number of &#39; \
                                                          &#39;gradients in &#39; \
                                                          &#39;pixel_array&#39;
        if ukrin_b:
            self.b_mask = np.isin(bvals, ukrin_b_test)
        else:
            self.b_mask = np.full(len(bvals), True, dtype=bool)

        self.pixel_array = pixel_array[..., self.b_mask]
        self.shape = self.pixel_array.shape[:-1]
        self.bvals = bvals[self.b_mask]
        self.bvecs = bvecs[self.b_mask, :]
        self.n_grad = len(self.bvals)
        self.u_bvals = unique_bvals_tolerance(self.bvals, 1)
        self.n_bvals = len(self.u_bvals)
        self.u_bvecs = np.unique(self.bvecs, axis=0)
        self.n_bvecs = len(self.u_bvecs)
        self.affine = affine
        self.mask = mask
        self.gtab = gradient_table(self.bvals, self.bvecs, b0_threshold=0)
        tensor_model = TensorModel(self.gtab)
        self.tensor_fit = tensor_model.fit(self.pixel_array, mask=self.mask)
        self.md = self.tensor_fit.md
        self.fa = self.tensor_fit.fa
        self.color_fa = self.tensor_fit.color_fa

    def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;,
                 maps=&#39;all&#39;):
        &#34;&#34;&#34;Exports maps generated by the DTI class as NIFTI.

        Parameters
        ----------
        output_directory : string, optional
            Path to the folder where the NIFTI files will be saved.
        base_file_name : string, optional
            Filename of the resulting NIFTI. This code appends the extension.
            Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
        maps : list or &#39;all&#39;, optional
            List of maps to save to NIFTI. This should either the string &#34;all&#34;
            or a list of maps from [&#34;md&#34;, &#34;fa&#34;, &#34;color_fa&#34;, &#34;mask&#34;].
        &#34;&#34;&#34;
        os.makedirs(output_directory, exist_ok=True)
        base_path = os.path.join(output_directory, base_file_name)
        if maps == &#39;all&#39; or maps == [&#39;all&#39;]:
            maps = [&#39;md&#39;, &#39;fa&#39;, &#39;color_fa&#39;, &#39;mask&#39;]
        if isinstance(maps, list):
            for result in maps:
                if result == &#39;md&#39; or result == &#39;md_map&#39;:
                    md_nifti = nib.Nifti1Image(self.md, affine=self.affine)
                    nib.save(md_nifti, base_path + &#39;_md_map.nii.gz&#39;)
                elif result == &#39;fa&#39; or result == &#39;fa_map&#39;:
                    fa_nifti = nib.Nifti1Image(self.fa, affine=self.affine)
                    nib.save(fa_nifti, base_path + &#39;_fa_map.nii.gz&#39;)
                elif result == &#39;color_fa&#39; or result == &#39;color_fa_map&#39;:
                    color_fa_nifti = nib.Nifti1Image(self.color_fa,
                                                     affine=self.affine)
                    nib.save(color_fa_nifti, base_path +
                             &#39;_color_fa_map.nii.gz&#39;)
                elif result == &#39;mask&#39;:
                    mask_nifti = nib.Nifti1Image(self.mask.astype(np.uint16),
                                                 affine=self.affine)
                    nib.save(mask_nifti, base_path + &#39;_mask.nii.gz&#39;)
        else:
            raise ValueError(&#39;No NIFTI file saved. The variable &#34;maps&#34; &#39;
                             &#39;should be &#34;all&#34; or a list of maps from &#39;
                             &#39;&#34;[&#34;md&#34;, &#34;fa&#34;, &#34;color_fa&#34;, &#34;mask&#34;]&#34;.&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ukat.mapping.diffusion.DTI.to_nifti"><code class="name flex">
<span>def <span class="ident">to_nifti</span></span>(<span>self, output_directory='/home/runner/work/ukat/ukat', base_file_name='Output', maps='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Exports maps generated by the DTI class as NIFTI.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>output_directory</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Path to the folder where the NIFTI files will be saved.</dd>
<dt><strong><code>base_file_name</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Filename of the resulting NIFTI. This code appends the extension.
Eg., base_file_name = 'Output' will result in 'Output.nii.gz'.</dd>
<dt><strong><code>maps</code></strong> :&ensp;<code>list</code> or <code>'all'</code>, optional</dt>
<dd>List of maps to save to NIFTI. This should either the string "all"
or a list of maps from ["md", "fa", "color_fa", "mask"].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;,
             maps=&#39;all&#39;):
    &#34;&#34;&#34;Exports maps generated by the DTI class as NIFTI.

    Parameters
    ----------
    output_directory : string, optional
        Path to the folder where the NIFTI files will be saved.
    base_file_name : string, optional
        Filename of the resulting NIFTI. This code appends the extension.
        Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
    maps : list or &#39;all&#39;, optional
        List of maps to save to NIFTI. This should either the string &#34;all&#34;
        or a list of maps from [&#34;md&#34;, &#34;fa&#34;, &#34;color_fa&#34;, &#34;mask&#34;].
    &#34;&#34;&#34;
    os.makedirs(output_directory, exist_ok=True)
    base_path = os.path.join(output_directory, base_file_name)
    if maps == &#39;all&#39; or maps == [&#39;all&#39;]:
        maps = [&#39;md&#39;, &#39;fa&#39;, &#39;color_fa&#39;, &#39;mask&#39;]
    if isinstance(maps, list):
        for result in maps:
            if result == &#39;md&#39; or result == &#39;md_map&#39;:
                md_nifti = nib.Nifti1Image(self.md, affine=self.affine)
                nib.save(md_nifti, base_path + &#39;_md_map.nii.gz&#39;)
            elif result == &#39;fa&#39; or result == &#39;fa_map&#39;:
                fa_nifti = nib.Nifti1Image(self.fa, affine=self.affine)
                nib.save(fa_nifti, base_path + &#39;_fa_map.nii.gz&#39;)
            elif result == &#39;color_fa&#39; or result == &#39;color_fa_map&#39;:
                color_fa_nifti = nib.Nifti1Image(self.color_fa,
                                                 affine=self.affine)
                nib.save(color_fa_nifti, base_path +
                         &#39;_color_fa_map.nii.gz&#39;)
            elif result == &#39;mask&#39;:
                mask_nifti = nib.Nifti1Image(self.mask.astype(np.uint16),
                                             affine=self.affine)
                nib.save(mask_nifti, base_path + &#39;_mask.nii.gz&#39;)
    else:
        raise ValueError(&#39;No NIFTI file saved. The variable &#34;maps&#34; &#39;
                         &#39;should be &#34;all&#34; or a list of maps from &#39;
                         &#39;&#34;[&#34;md&#34;, &#34;fa&#34;, &#34;color_fa&#34;, &#34;mask&#34;]&#34;.&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ukat.mapping" href="index.html">ukat.mapping</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ukat.mapping.diffusion.make_gradient_scheme" href="#ukat.mapping.diffusion.make_gradient_scheme">make_gradient_scheme</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ukat.mapping.diffusion.ADC" href="#ukat.mapping.diffusion.ADC">ADC</a></code></h4>
<ul class="">
<li><code><a title="ukat.mapping.diffusion.ADC.to_nifti" href="#ukat.mapping.diffusion.ADC.to_nifti">to_nifti</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ukat.mapping.diffusion.DTI" href="#ukat.mapping.diffusion.DTI">DTI</a></code></h4>
<ul class="">
<li><code><a title="ukat.mapping.diffusion.DTI.to_nifti" href="#ukat.mapping.diffusion.DTI.to_nifti">to_nifti</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>