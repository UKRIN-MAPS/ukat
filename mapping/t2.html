<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ukat.mapping.t2 API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ukat.mapping.t2</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import nibabel as nib
import numpy as np
import concurrent.futures
from tqdm import tqdm
from scipy.optimize import curve_fit


class T2:
    &#34;&#34;&#34;
    Attributes
    ----------
    t2_map : np.ndarray
        The estimated T2 values in ms
    t2_err : np.ndarray
        The certainty in the fit of `t2` in ms
    m0_map : np.ndarray
        The estimated M0 values
    m0_err : np.ndarray
        The certainty in the fit of `m0`
    shape : tuple
        The shape of the T2 map
    n_te : int
        The number of TE used to calculate the map
    n_vox : int
        The number of voxels in the map i.e. the product of all dimensions
        apart from TE
    &#34;&#34;&#34;

    def __init__(self, pixel_array, echo_list, affine, mask=None,
                 noise_threshold=0, method=&#39;2p_exp&#39;, multithread=&#39;auto&#39;):
        &#34;&#34;&#34;Initialise a T2 class instance.

        Parameters
        ----------
        pixel_array : np.ndarray
            An array containing the signal from each voxel at each echo
            time with the last dimension being time i.e. the array needed to
            generate a 3D T2 map would have dimensions [x, y, z, TE].
        echo_list : list()
            An array of the echo times used for the last dimension of the
            raw data. In milliseconds.
        affine : np.ndarray
            A matrix giving the relationship between voxel coordinates and
            world coordinates.
        mask : np.ndarray, optional
            A boolean mask of the voxels to fit. Should be the shape of the
            desired T2 map rather than the raw data i.e. omit the time
            dimension.
        noise_threshold : float, optional
            Default 0
            Voxels with magnitude less than this threshold will not be used
            when fitting. This can be useful if the noise floor of the data
            is known.
        method : {&#39;2p_exp&#39;, &#39;3p_exp&#39;}, optional
            Default `2p_exp`
            The model the data is fit to. 2p_exp uses a two parameter
            exponential model (S = S0 * exp(-t / T2)) whereas 3p_exp uses a
            three parameter exponential model (S = S0 * exp(-t / T2) + b) to
            fit for noise/very long T2 components of the signal.
        multithread : bool or &#39;auto&#39;, optional
            Default &#39;auto&#39;.
            If True, fitting will be distributed over all cores available on
            the node. If False, fitting will be carried out on a single thread.
            &#39;auto&#39; attempts to apply multithreading where appropriate based
            on the number of voxels being fit.
        &#34;&#34;&#34;
        # Some sanity checks
        assert (pixel_array.shape[-1]
                == len(echo_list)), &#39;Number of echoes does not match the &#39; \
                                    &#39;number of time frames on the last axis &#39; \
                                    &#39;of pixel_array&#39;
        assert multithread is True \
            or multithread is False \
            or multithread == &#39;auto&#39;, &#39;multithreaded must be True, &#39; \
                                      &#39;False or auto. You entered {}&#39; \
            .format(multithread)
        if method != &#39;2p_exp&#39; and method != &#39;3p_exp&#39;:
            raise ValueError(&#39;method can be 2p_exp or 3p_exp only. You &#39;
                             &#39;specified {}&#39;.format(method))

        self.pixel_array = pixel_array
        self.shape = pixel_array.shape[:-1]
        self.n_te = pixel_array.shape[-1]
        self.n_vox = np.prod(self.shape)
        self.affine = affine
        # Generate a mask if there isn&#39;t one specified
        if mask is None:
            self.mask = np.ones(self.shape, dtype=bool)
        else:
            self.mask = mask
            # Don&#39;t process any nan values
        self.mask[np.isnan(np.sum(pixel_array, axis=-1))] = False
        self.noise_threshold = noise_threshold
        self.method = method
        self.echo_list = echo_list
        # Auto multithreading conditions
        if multithread == &#39;auto&#39;:
            if self.n_vox &gt; 20:
                multithread = True
            else:
                multithread = False
        self.multithread = multithread

        # Fit data
        if self.method == &#39;2p_exp&#39;:
            self.t2_map, self.t2_err, \
                self.m0_map, self.m0_err \
                = self.__fit__()
        elif self.method == &#39;3p_exp&#39;:
            self.t2_map, self.t2_err, \
                self.m0_map, self.m0_err, \
                self.b_map, self.b_err \
                = self.__fit__()

    def __fit__(self):

        # Initialise maps
        t2_map = np.zeros(self.n_vox)
        t2_err = np.zeros(self.n_vox)
        m0_map = np.zeros(self.n_vox)
        m0_err = np.zeros(self.n_vox)
        b_map = np.zeros(self.n_vox)
        b_err = np.zeros(self.n_vox)
        mask = self.mask.flatten()
        signal = self.pixel_array.reshape(-1, self.n_te)
        # Get indices of voxels to process
        idx = np.argwhere(mask).squeeze()

        # Multithreaded method
        if self.multithread:
            with concurrent.futures.ProcessPoolExecutor() as pool:
                with tqdm(total=idx.size) as progress:
                    futures = []

                    for ind in idx:
                        signal_thresh = signal[ind, :][
                            signal[ind, :] &gt; self.noise_threshold]
                        echo_list_thresh = self.echo_list[
                            signal[ind, :] &gt; self.noise_threshold]
                        future = pool.submit(self.__fit_signal__,
                                             signal_thresh,
                                             echo_list_thresh)
                        future.add_done_callback(lambda p: progress.update())
                        futures.append(future)

                    results = []
                    for future in futures:
                        result = future.result()
                        results.append(result)

            if self.method == &#39;2p_exp&#39;:
                t2_map[idx], t2_err[idx], m0_map[idx], m0_err[idx] = [np.array(
                    row) for row in zip(*results)]
            elif self.method == &#39;3p_exp&#39;:
                t2_map[idx], t2_err[idx], \
                    m0_map[idx], m0_err[idx], \
                    b_map[idx], b_err[idx] = \
                    [np.array(row) for row in zip(*results)]

        # Single threaded method
        else:
            with tqdm(total=idx.size) as progress:
                for ind in idx:
                    signal_thresh = signal[ind, :][
                        signal[ind, :] &gt; self.noise_threshold]
                    echo_list_thresh = self.echo_list[
                        signal[ind, :] &gt; self.noise_threshold]
                    if self.method == &#39;2p_exp&#39;:
                        t2_map[ind], t2_err[ind], \
                            m0_map[ind], m0_err[ind] \
                            = self.__fit_signal__(signal_thresh,
                                                  echo_list_thresh)
                    elif self.method == &#39;3p_exp&#39;:
                        t2_map[ind], t2_err[ind], \
                            m0_map[ind], m0_err[ind], \
                            b_map[ind], b_err[ind] \
                            = self.__fit_signal__(signal_thresh,
                                                  echo_list_thresh)
                    progress.update(1)

        # Reshape results to raw data shape
        t2_map = t2_map.reshape(self.shape)
        t2_err = t2_err.reshape(self.shape)
        m0_map = m0_map.reshape(self.shape)
        m0_err = m0_err.reshape(self.shape)

        if self.method == &#39;2p_exp&#39;:
            return t2_map, t2_err, m0_map, m0_err
        elif self.method == &#39;3p_exp&#39;:
            b_map = b_map.reshape(self.shape)
            b_err = b_err.reshape(self.shape)
            return t2_map, t2_err, m0_map, m0_err, b_map, b_err

    def __fit_signal__(self, sig, te):

        # Initialise parameters
        if self.method == &#39;2p_exp&#39;:
            eq = two_param_eq
            bounds = ([0, 0], [1000, 100000000])
            initial_guess = [20, 10000]
        elif self.method == &#39;3p_exp&#39;:
            eq = three_param_eq
            bounds = ([0, 0, 0], [1000, 100000000, 1000000])
            initial_guess = [20, 10000, 500]

        # Fit data to equation
        try:
            popt, pcov = curve_fit(eq, te, sig, p0=initial_guess,
                                   bounds=bounds)
        except (RuntimeError, ValueError):
            popt = np.zeros(3)
            pcov = np.zeros((3, 3))

        # Extract fits and errors from result variables
        if self.method == &#39;2p_exp&#39;:
            if popt[0] &lt; bounds[1][0] - 1:
                t2 = popt[0]
                m0 = popt[1]
                err = np.sqrt(np.diag(pcov))
                t2_err = err[0]
                m0_err = err[1]
            else:
                t2, m0, t2_err, m0_err = 0, 0, 0, 0

            return t2, t2_err, m0, m0_err

        elif self.method == &#39;3p_exp&#39;:
            if popt[0] &lt; bounds[1][0] - 1:
                t2 = popt[0]
                m0 = popt[1]
                b = popt[2]
                err = np.sqrt(np.diag(pcov))
                t2_err = err[0]
                m0_err = err[1]
                b_err = err[2]
            else:
                t2, m0, t2_err, m0_err, b, b_err = 0, 0, 0, 0, 0, 0

            return t2, t2_err, m0, m0_err, b, b_err

    def r2_map(self):
        &#34;&#34;&#34;
        Generates the R2 map from the T2 map output by initialising this
        class.

        Parameters
        ----------
        See class attributes in __init__

        Returns
        -------
        r2 : np.ndarray
            An array containing the R2 map generated
            by the function with R2 measured in ms.
        &#34;&#34;&#34;
        return np.reciprocal(self.t2_map)

    def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;,
                 maps=&#39;all&#39;):
        &#34;&#34;&#34;Exports some of the T2 class attributes to NIFTI.
                        
        Parameters
        ----------
        output_directory : string, optional
            Path to the folder where the NIFTI files will be saved.
        base_file_name : string, optional
            Filename of the resulting NIFTI. This code appends the extension.
            Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
        maps : list or &#39;all&#39;, optional
            List of maps to save to NIFTI. This should either the string &#34;all&#34;
            or a list of maps from [&#34;t2&#34;, &#34;t2_err&#34;, &#34;m0&#34;, &#34;m0_err&#34;,
            &#34;r2&#34;, &#34;mask&#34;].
        &#34;&#34;&#34;
        os.makedirs(output_directory, exist_ok=True)
        base_path = os.path.join(output_directory, base_file_name)
        if maps == &#39;all&#39; or maps == [&#39;all&#39;]:
            maps = [&#39;t2&#39;, &#39;t2_err&#39;, &#39;m0&#39;, &#39;m0_err&#39;, &#39;r2&#39;, &#39;mask&#39;]
        if isinstance(maps, list):
            for result in maps:
                if result == &#39;t2&#39; or result == &#39;t2_map&#39;:
                    t2_nifti = nib.Nifti1Image(self.t2_map, affine=self.affine)
                    nib.save(t2_nifti, base_path + &#39;_t2_map.nii.gz&#39;)
                elif result == &#39;t2_err&#39;:
                    t2_err_nifti = nib.Nifti1Image(self.t2_err,
                                                   affine=self.affine)
                    nib.save(t2_err_nifti, base_path + &#39;_t2_err.nii.gz&#39;)
                elif result == &#39;m0&#39; or result == &#39;m0_map&#39;:
                    m0_nifti = nib.Nifti1Image(self.m0_map, affine=self.affine)
                    nib.save(m0_nifti, base_path + &#39;_m0_map.nii.gz&#39;)
                elif result == &#39;m0_err&#39;:
                    m0_err_nifti = nib.Nifti1Image(self.m0_err,
                                                   affine=self.affine)
                    nib.save(m0_err_nifti, base_path + &#39;_m0_err.nii.gz&#39;)
                elif result == &#39;r2&#39; or result == &#39;r2_map&#39;:
                    r2_nifti = nib.Nifti1Image(T2.r2_map(self),
                                               affine=self.affine)
                    nib.save(r2_nifti, base_path + &#39;_r2_map.nii.gz&#39;)
                elif result == &#39;mask&#39;:
                    mask_nifti = nib.Nifti1Image(self.mask.astype(int),
                                                 affine=self.affine)
                    nib.save(mask_nifti, base_path + &#39;_mask.nii.gz&#39;)
        else:
            raise ValueError(&#39;No NIFTI file saved. The variable &#34;maps&#34; &#39;
                             &#39;should be &#34;all&#34; or a list of maps from &#39;
                             &#39;&#34;[&#34;t2&#34;, &#34;t2_err&#34;, &#34;m0&#34;, &#34;m0_err&#34;, &#34;r2&#34;, &#39;
                             &#39;&#34;mask&#34;]&#34;.&#39;)

        return


def two_param_eq(t, t2, m0):
    &#34;&#34;&#34;
        Calculate the expected signal from the equation
        signal = M0 * exp(-t / T2)

        Parameters
        ----------
        t: list
            The times the signal will be calculated at
        t2: float
            The T2 of the signal
        m0: float
            The M0 of the signal

        Returns
        -------
        signal: np.ndarray
            The expected signal
        &#34;&#34;&#34;
    return np.sqrt(np.square(m0 * np.exp(-t / t2)))


def three_param_eq(t, t2, m0, b):
    &#34;&#34;&#34;
        Calculate the expected signal from the equation
        signal = M0 * exp(-t / T2) + b

        Parameters
        ----------
        t: list
            The times the signal will be calculated at
        t2: float
            The T2 of the signal
        m0: float
            The M0 of the signal
        b: float
            The baseline noise floor of the signal

        Returns
        -------
        signal: np.ndarray
            The expected signal
        &#34;&#34;&#34;
    return np.sqrt(np.square(m0 * np.exp(-t / t2) + b))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ukat.mapping.t2.three_param_eq"><code class="name flex">
<span>def <span class="ident">three_param_eq</span></span>(<span>t, t2, m0, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the expected signal from the equation
signal = M0 * exp(-t / T2) + b</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>list</code></dt>
<dd>The times the signal will be calculated at</dd>
<dt><strong><code>t2</code></strong> :&ensp;<code>float</code></dt>
<dd>The T2 of the signal</dd>
<dt><strong><code>m0</code></strong> :&ensp;<code>float</code></dt>
<dd>The M0 of the signal</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code></dt>
<dd>The baseline noise floor of the signal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>signal</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The expected signal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def three_param_eq(t, t2, m0, b):
    &#34;&#34;&#34;
        Calculate the expected signal from the equation
        signal = M0 * exp(-t / T2) + b

        Parameters
        ----------
        t: list
            The times the signal will be calculated at
        t2: float
            The T2 of the signal
        m0: float
            The M0 of the signal
        b: float
            The baseline noise floor of the signal

        Returns
        -------
        signal: np.ndarray
            The expected signal
        &#34;&#34;&#34;
    return np.sqrt(np.square(m0 * np.exp(-t / t2) + b))</code></pre>
</details>
</dd>
<dt id="ukat.mapping.t2.two_param_eq"><code class="name flex">
<span>def <span class="ident">two_param_eq</span></span>(<span>t, t2, m0)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the expected signal from the equation
signal = M0 * exp(-t / T2)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>list</code></dt>
<dd>The times the signal will be calculated at</dd>
<dt><strong><code>t2</code></strong> :&ensp;<code>float</code></dt>
<dd>The T2 of the signal</dd>
<dt><strong><code>m0</code></strong> :&ensp;<code>float</code></dt>
<dd>The M0 of the signal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>signal</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The expected signal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def two_param_eq(t, t2, m0):
    &#34;&#34;&#34;
        Calculate the expected signal from the equation
        signal = M0 * exp(-t / T2)

        Parameters
        ----------
        t: list
            The times the signal will be calculated at
        t2: float
            The T2 of the signal
        m0: float
            The M0 of the signal

        Returns
        -------
        signal: np.ndarray
            The expected signal
        &#34;&#34;&#34;
    return np.sqrt(np.square(m0 * np.exp(-t / t2)))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ukat.mapping.t2.T2"><code class="flex name class">
<span>class <span class="ident">T2</span></span>
<span>(</span><span>pixel_array, echo_list, affine, mask=None, noise_threshold=0, method='2p_exp', multithread='auto')</span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>t2_map</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The estimated T2 values in ms</dd>
<dt><strong><code>t2_err</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The certainty in the fit of <code>t2</code> in ms</dd>
<dt><strong><code>m0_map</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The estimated M0 values</dd>
<dt><strong><code>m0_err</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The certainty in the fit of <code>m0</code></dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The shape of the T2 map</dd>
<dt><strong><code>n_te</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of TE used to calculate the map</dd>
<dt><strong><code>n_vox</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of voxels in the map i.e. the product of all dimensions
apart from TE</dd>
</dl>
<p>Initialise a T2 class instance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pixel_array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>An array containing the signal from each voxel at each echo
time with the last dimension being time i.e. the array needed to
generate a 3D T2 map would have dimensions [x, y, z, TE].</dd>
<dt><strong><code>echo_list</code></strong> :&ensp;<code>list()</code></dt>
<dd>An array of the echo times used for the last dimension of the
raw data. In milliseconds.</dd>
<dt><strong><code>affine</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A matrix giving the relationship between voxel coordinates and
world coordinates.</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>np.ndarray</code>, optional</dt>
<dd>A boolean mask of the voxels to fit. Should be the shape of the
desired T2 map rather than the raw data i.e. omit the time
dimension.</dd>
<dt><strong><code>noise_threshold</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Default 0
Voxels with magnitude less than this threshold will not be used
when fitting. This can be useful if the noise floor of the data
is known.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>{'2p_exp', '3p_exp'}</code>, optional</dt>
<dd>Default <code>2p_exp</code>
The model the data is fit to. 2p_exp uses a two parameter
exponential model (S = S0 * exp(-t / T2)) whereas 3p_exp uses a
three parameter exponential model (S = S0 * exp(-t / T2) + b) to
fit for noise/very long T2 components of the signal.</dd>
<dt><strong><code>multithread</code></strong> :&ensp;<code>bool</code> or <code>'auto'</code>, optional</dt>
<dd>Default 'auto'.
If True, fitting will be distributed over all cores available on
the node. If False, fitting will be carried out on a single thread.
'auto' attempts to apply multithreading where appropriate based
on the number of voxels being fit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class T2:
    &#34;&#34;&#34;
    Attributes
    ----------
    t2_map : np.ndarray
        The estimated T2 values in ms
    t2_err : np.ndarray
        The certainty in the fit of `t2` in ms
    m0_map : np.ndarray
        The estimated M0 values
    m0_err : np.ndarray
        The certainty in the fit of `m0`
    shape : tuple
        The shape of the T2 map
    n_te : int
        The number of TE used to calculate the map
    n_vox : int
        The number of voxels in the map i.e. the product of all dimensions
        apart from TE
    &#34;&#34;&#34;

    def __init__(self, pixel_array, echo_list, affine, mask=None,
                 noise_threshold=0, method=&#39;2p_exp&#39;, multithread=&#39;auto&#39;):
        &#34;&#34;&#34;Initialise a T2 class instance.

        Parameters
        ----------
        pixel_array : np.ndarray
            An array containing the signal from each voxel at each echo
            time with the last dimension being time i.e. the array needed to
            generate a 3D T2 map would have dimensions [x, y, z, TE].
        echo_list : list()
            An array of the echo times used for the last dimension of the
            raw data. In milliseconds.
        affine : np.ndarray
            A matrix giving the relationship between voxel coordinates and
            world coordinates.
        mask : np.ndarray, optional
            A boolean mask of the voxels to fit. Should be the shape of the
            desired T2 map rather than the raw data i.e. omit the time
            dimension.
        noise_threshold : float, optional
            Default 0
            Voxels with magnitude less than this threshold will not be used
            when fitting. This can be useful if the noise floor of the data
            is known.
        method : {&#39;2p_exp&#39;, &#39;3p_exp&#39;}, optional
            Default `2p_exp`
            The model the data is fit to. 2p_exp uses a two parameter
            exponential model (S = S0 * exp(-t / T2)) whereas 3p_exp uses a
            three parameter exponential model (S = S0 * exp(-t / T2) + b) to
            fit for noise/very long T2 components of the signal.
        multithread : bool or &#39;auto&#39;, optional
            Default &#39;auto&#39;.
            If True, fitting will be distributed over all cores available on
            the node. If False, fitting will be carried out on a single thread.
            &#39;auto&#39; attempts to apply multithreading where appropriate based
            on the number of voxels being fit.
        &#34;&#34;&#34;
        # Some sanity checks
        assert (pixel_array.shape[-1]
                == len(echo_list)), &#39;Number of echoes does not match the &#39; \
                                    &#39;number of time frames on the last axis &#39; \
                                    &#39;of pixel_array&#39;
        assert multithread is True \
            or multithread is False \
            or multithread == &#39;auto&#39;, &#39;multithreaded must be True, &#39; \
                                      &#39;False or auto. You entered {}&#39; \
            .format(multithread)
        if method != &#39;2p_exp&#39; and method != &#39;3p_exp&#39;:
            raise ValueError(&#39;method can be 2p_exp or 3p_exp only. You &#39;
                             &#39;specified {}&#39;.format(method))

        self.pixel_array = pixel_array
        self.shape = pixel_array.shape[:-1]
        self.n_te = pixel_array.shape[-1]
        self.n_vox = np.prod(self.shape)
        self.affine = affine
        # Generate a mask if there isn&#39;t one specified
        if mask is None:
            self.mask = np.ones(self.shape, dtype=bool)
        else:
            self.mask = mask
            # Don&#39;t process any nan values
        self.mask[np.isnan(np.sum(pixel_array, axis=-1))] = False
        self.noise_threshold = noise_threshold
        self.method = method
        self.echo_list = echo_list
        # Auto multithreading conditions
        if multithread == &#39;auto&#39;:
            if self.n_vox &gt; 20:
                multithread = True
            else:
                multithread = False
        self.multithread = multithread

        # Fit data
        if self.method == &#39;2p_exp&#39;:
            self.t2_map, self.t2_err, \
                self.m0_map, self.m0_err \
                = self.__fit__()
        elif self.method == &#39;3p_exp&#39;:
            self.t2_map, self.t2_err, \
                self.m0_map, self.m0_err, \
                self.b_map, self.b_err \
                = self.__fit__()

    def __fit__(self):

        # Initialise maps
        t2_map = np.zeros(self.n_vox)
        t2_err = np.zeros(self.n_vox)
        m0_map = np.zeros(self.n_vox)
        m0_err = np.zeros(self.n_vox)
        b_map = np.zeros(self.n_vox)
        b_err = np.zeros(self.n_vox)
        mask = self.mask.flatten()
        signal = self.pixel_array.reshape(-1, self.n_te)
        # Get indices of voxels to process
        idx = np.argwhere(mask).squeeze()

        # Multithreaded method
        if self.multithread:
            with concurrent.futures.ProcessPoolExecutor() as pool:
                with tqdm(total=idx.size) as progress:
                    futures = []

                    for ind in idx:
                        signal_thresh = signal[ind, :][
                            signal[ind, :] &gt; self.noise_threshold]
                        echo_list_thresh = self.echo_list[
                            signal[ind, :] &gt; self.noise_threshold]
                        future = pool.submit(self.__fit_signal__,
                                             signal_thresh,
                                             echo_list_thresh)
                        future.add_done_callback(lambda p: progress.update())
                        futures.append(future)

                    results = []
                    for future in futures:
                        result = future.result()
                        results.append(result)

            if self.method == &#39;2p_exp&#39;:
                t2_map[idx], t2_err[idx], m0_map[idx], m0_err[idx] = [np.array(
                    row) for row in zip(*results)]
            elif self.method == &#39;3p_exp&#39;:
                t2_map[idx], t2_err[idx], \
                    m0_map[idx], m0_err[idx], \
                    b_map[idx], b_err[idx] = \
                    [np.array(row) for row in zip(*results)]

        # Single threaded method
        else:
            with tqdm(total=idx.size) as progress:
                for ind in idx:
                    signal_thresh = signal[ind, :][
                        signal[ind, :] &gt; self.noise_threshold]
                    echo_list_thresh = self.echo_list[
                        signal[ind, :] &gt; self.noise_threshold]
                    if self.method == &#39;2p_exp&#39;:
                        t2_map[ind], t2_err[ind], \
                            m0_map[ind], m0_err[ind] \
                            = self.__fit_signal__(signal_thresh,
                                                  echo_list_thresh)
                    elif self.method == &#39;3p_exp&#39;:
                        t2_map[ind], t2_err[ind], \
                            m0_map[ind], m0_err[ind], \
                            b_map[ind], b_err[ind] \
                            = self.__fit_signal__(signal_thresh,
                                                  echo_list_thresh)
                    progress.update(1)

        # Reshape results to raw data shape
        t2_map = t2_map.reshape(self.shape)
        t2_err = t2_err.reshape(self.shape)
        m0_map = m0_map.reshape(self.shape)
        m0_err = m0_err.reshape(self.shape)

        if self.method == &#39;2p_exp&#39;:
            return t2_map, t2_err, m0_map, m0_err
        elif self.method == &#39;3p_exp&#39;:
            b_map = b_map.reshape(self.shape)
            b_err = b_err.reshape(self.shape)
            return t2_map, t2_err, m0_map, m0_err, b_map, b_err

    def __fit_signal__(self, sig, te):

        # Initialise parameters
        if self.method == &#39;2p_exp&#39;:
            eq = two_param_eq
            bounds = ([0, 0], [1000, 100000000])
            initial_guess = [20, 10000]
        elif self.method == &#39;3p_exp&#39;:
            eq = three_param_eq
            bounds = ([0, 0, 0], [1000, 100000000, 1000000])
            initial_guess = [20, 10000, 500]

        # Fit data to equation
        try:
            popt, pcov = curve_fit(eq, te, sig, p0=initial_guess,
                                   bounds=bounds)
        except (RuntimeError, ValueError):
            popt = np.zeros(3)
            pcov = np.zeros((3, 3))

        # Extract fits and errors from result variables
        if self.method == &#39;2p_exp&#39;:
            if popt[0] &lt; bounds[1][0] - 1:
                t2 = popt[0]
                m0 = popt[1]
                err = np.sqrt(np.diag(pcov))
                t2_err = err[0]
                m0_err = err[1]
            else:
                t2, m0, t2_err, m0_err = 0, 0, 0, 0

            return t2, t2_err, m0, m0_err

        elif self.method == &#39;3p_exp&#39;:
            if popt[0] &lt; bounds[1][0] - 1:
                t2 = popt[0]
                m0 = popt[1]
                b = popt[2]
                err = np.sqrt(np.diag(pcov))
                t2_err = err[0]
                m0_err = err[1]
                b_err = err[2]
            else:
                t2, m0, t2_err, m0_err, b, b_err = 0, 0, 0, 0, 0, 0

            return t2, t2_err, m0, m0_err, b, b_err

    def r2_map(self):
        &#34;&#34;&#34;
        Generates the R2 map from the T2 map output by initialising this
        class.

        Parameters
        ----------
        See class attributes in __init__

        Returns
        -------
        r2 : np.ndarray
            An array containing the R2 map generated
            by the function with R2 measured in ms.
        &#34;&#34;&#34;
        return np.reciprocal(self.t2_map)

    def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;,
                 maps=&#39;all&#39;):
        &#34;&#34;&#34;Exports some of the T2 class attributes to NIFTI.
                        
        Parameters
        ----------
        output_directory : string, optional
            Path to the folder where the NIFTI files will be saved.
        base_file_name : string, optional
            Filename of the resulting NIFTI. This code appends the extension.
            Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
        maps : list or &#39;all&#39;, optional
            List of maps to save to NIFTI. This should either the string &#34;all&#34;
            or a list of maps from [&#34;t2&#34;, &#34;t2_err&#34;, &#34;m0&#34;, &#34;m0_err&#34;,
            &#34;r2&#34;, &#34;mask&#34;].
        &#34;&#34;&#34;
        os.makedirs(output_directory, exist_ok=True)
        base_path = os.path.join(output_directory, base_file_name)
        if maps == &#39;all&#39; or maps == [&#39;all&#39;]:
            maps = [&#39;t2&#39;, &#39;t2_err&#39;, &#39;m0&#39;, &#39;m0_err&#39;, &#39;r2&#39;, &#39;mask&#39;]
        if isinstance(maps, list):
            for result in maps:
                if result == &#39;t2&#39; or result == &#39;t2_map&#39;:
                    t2_nifti = nib.Nifti1Image(self.t2_map, affine=self.affine)
                    nib.save(t2_nifti, base_path + &#39;_t2_map.nii.gz&#39;)
                elif result == &#39;t2_err&#39;:
                    t2_err_nifti = nib.Nifti1Image(self.t2_err,
                                                   affine=self.affine)
                    nib.save(t2_err_nifti, base_path + &#39;_t2_err.nii.gz&#39;)
                elif result == &#39;m0&#39; or result == &#39;m0_map&#39;:
                    m0_nifti = nib.Nifti1Image(self.m0_map, affine=self.affine)
                    nib.save(m0_nifti, base_path + &#39;_m0_map.nii.gz&#39;)
                elif result == &#39;m0_err&#39;:
                    m0_err_nifti = nib.Nifti1Image(self.m0_err,
                                                   affine=self.affine)
                    nib.save(m0_err_nifti, base_path + &#39;_m0_err.nii.gz&#39;)
                elif result == &#39;r2&#39; or result == &#39;r2_map&#39;:
                    r2_nifti = nib.Nifti1Image(T2.r2_map(self),
                                               affine=self.affine)
                    nib.save(r2_nifti, base_path + &#39;_r2_map.nii.gz&#39;)
                elif result == &#39;mask&#39;:
                    mask_nifti = nib.Nifti1Image(self.mask.astype(int),
                                                 affine=self.affine)
                    nib.save(mask_nifti, base_path + &#39;_mask.nii.gz&#39;)
        else:
            raise ValueError(&#39;No NIFTI file saved. The variable &#34;maps&#34; &#39;
                             &#39;should be &#34;all&#34; or a list of maps from &#39;
                             &#39;&#34;[&#34;t2&#34;, &#34;t2_err&#34;, &#34;m0&#34;, &#34;m0_err&#34;, &#34;r2&#34;, &#39;
                             &#39;&#34;mask&#34;]&#34;.&#39;)

        return</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ukat.mapping.t2.T2.r2_map"><code class="name flex">
<span>def <span class="ident">r2_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the R2 map from the T2 map output by initialising this
class.</p>
<h2 id="parameters">Parameters</h2>
<p>See class attributes in <strong>init</strong></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>r2</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>An array containing the R2 map generated
by the function with R2 measured in ms.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def r2_map(self):
    &#34;&#34;&#34;
    Generates the R2 map from the T2 map output by initialising this
    class.

    Parameters
    ----------
    See class attributes in __init__

    Returns
    -------
    r2 : np.ndarray
        An array containing the R2 map generated
        by the function with R2 measured in ms.
    &#34;&#34;&#34;
    return np.reciprocal(self.t2_map)</code></pre>
</details>
</dd>
<dt id="ukat.mapping.t2.T2.to_nifti"><code class="name flex">
<span>def <span class="ident">to_nifti</span></span>(<span>self, output_directory='/home/runner/work/ukat/ukat', base_file_name='Output', maps='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Exports some of the T2 class attributes to NIFTI.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>output_directory</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Path to the folder where the NIFTI files will be saved.</dd>
<dt><strong><code>base_file_name</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Filename of the resulting NIFTI. This code appends the extension.
Eg., base_file_name = 'Output' will result in 'Output.nii.gz'.</dd>
<dt><strong><code>maps</code></strong> :&ensp;<code>list</code> or <code>'all'</code>, optional</dt>
<dd>List of maps to save to NIFTI. This should either the string "all"
or a list of maps from ["t2", "t2_err", "m0", "m0_err",
"r2", "mask"].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;,
             maps=&#39;all&#39;):
    &#34;&#34;&#34;Exports some of the T2 class attributes to NIFTI.
                    
    Parameters
    ----------
    output_directory : string, optional
        Path to the folder where the NIFTI files will be saved.
    base_file_name : string, optional
        Filename of the resulting NIFTI. This code appends the extension.
        Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
    maps : list or &#39;all&#39;, optional
        List of maps to save to NIFTI. This should either the string &#34;all&#34;
        or a list of maps from [&#34;t2&#34;, &#34;t2_err&#34;, &#34;m0&#34;, &#34;m0_err&#34;,
        &#34;r2&#34;, &#34;mask&#34;].
    &#34;&#34;&#34;
    os.makedirs(output_directory, exist_ok=True)
    base_path = os.path.join(output_directory, base_file_name)
    if maps == &#39;all&#39; or maps == [&#39;all&#39;]:
        maps = [&#39;t2&#39;, &#39;t2_err&#39;, &#39;m0&#39;, &#39;m0_err&#39;, &#39;r2&#39;, &#39;mask&#39;]
    if isinstance(maps, list):
        for result in maps:
            if result == &#39;t2&#39; or result == &#39;t2_map&#39;:
                t2_nifti = nib.Nifti1Image(self.t2_map, affine=self.affine)
                nib.save(t2_nifti, base_path + &#39;_t2_map.nii.gz&#39;)
            elif result == &#39;t2_err&#39;:
                t2_err_nifti = nib.Nifti1Image(self.t2_err,
                                               affine=self.affine)
                nib.save(t2_err_nifti, base_path + &#39;_t2_err.nii.gz&#39;)
            elif result == &#39;m0&#39; or result == &#39;m0_map&#39;:
                m0_nifti = nib.Nifti1Image(self.m0_map, affine=self.affine)
                nib.save(m0_nifti, base_path + &#39;_m0_map.nii.gz&#39;)
            elif result == &#39;m0_err&#39;:
                m0_err_nifti = nib.Nifti1Image(self.m0_err,
                                               affine=self.affine)
                nib.save(m0_err_nifti, base_path + &#39;_m0_err.nii.gz&#39;)
            elif result == &#39;r2&#39; or result == &#39;r2_map&#39;:
                r2_nifti = nib.Nifti1Image(T2.r2_map(self),
                                           affine=self.affine)
                nib.save(r2_nifti, base_path + &#39;_r2_map.nii.gz&#39;)
            elif result == &#39;mask&#39;:
                mask_nifti = nib.Nifti1Image(self.mask.astype(int),
                                             affine=self.affine)
                nib.save(mask_nifti, base_path + &#39;_mask.nii.gz&#39;)
    else:
        raise ValueError(&#39;No NIFTI file saved. The variable &#34;maps&#34; &#39;
                         &#39;should be &#34;all&#34; or a list of maps from &#39;
                         &#39;&#34;[&#34;t2&#34;, &#34;t2_err&#34;, &#34;m0&#34;, &#34;m0_err&#34;, &#34;r2&#34;, &#39;
                         &#39;&#34;mask&#34;]&#34;.&#39;)

    return</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ukat.mapping" href="index.html">ukat.mapping</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ukat.mapping.t2.three_param_eq" href="#ukat.mapping.t2.three_param_eq">three_param_eq</a></code></li>
<li><code><a title="ukat.mapping.t2.two_param_eq" href="#ukat.mapping.t2.two_param_eq">two_param_eq</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ukat.mapping.t2.T2" href="#ukat.mapping.t2.T2">T2</a></code></h4>
<ul class="">
<li><code><a title="ukat.mapping.t2.T2.r2_map" href="#ukat.mapping.t2.T2.r2_map">r2_map</a></code></li>
<li><code><a title="ukat.mapping.t2.T2.to_nifti" href="#ukat.mapping.t2.T2.to_nifti">to_nifti</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>