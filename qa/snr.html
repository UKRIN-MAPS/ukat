<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ukat.qa.snr API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ukat.qa.snr</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import nibabel as nib
import numpy as np
import os

from sklearn.mixture import BayesianGaussianMixture


class Isnr:
    &#34;&#34;&#34;
        Attributes
        ----------
        isnr : float
            Image signal to noise ratio.
        isnr_map : np.ndarray
            A map of the image signal to noise ratio.
        noise_mask : np.ndarray
            Mask of the ROI used to measure noise levels. Should be voxels
            outside the body.
        clusters : np.ndarray
            The labels assigned to each voxel during automatic background
            segmentation. This can be useful for debugging.
        &#34;&#34;&#34;

    def __init__(self, pixel_array, affine, noise_mask=None, n_clusters=3):
        &#34;&#34;&#34;Initialise an image signal to noise ratio (iSNR) class instance.
        Parameters
        ----------
        pixel_array : np.ndarray
            Array of voxels over which iSNR should be calculated.
        affine : np.ndarray
            A matrix giving the relationship between voxel coordinates and
            world coordinates.
        noise_mask : np.ndarray, optional
            A binary voxel mask where voxels representing background i.e.
            outside the body, are True. If no mask is supplied, one is
            estimated using a Bayesian Gaussian mixture model to segment
            background voxels.
        n_clusters : int, optional
            When using the automatic background segmentation this is the
            total number of componenets the image is segmented into. The
            component with the lowest mean is assumed to be background.
            Default 3.
        &#34;&#34;&#34;
        self.pixel_array = pixel_array
        self.affine = affine
        self.n_clusters = n_clusters
        self.shape = pixel_array.shape
        self.dimensions = len(pixel_array.shape)

        if noise_mask is None:
            self.__mask_background__()
        else:
            self.noise_mask = noise_mask
            self.clusters = np.nan

        self.isnr = np.nan
        self.isnr_map = np.zeros(self.shape)
        self.__snr__()

    def __mask_background__(self):
        np.random.seed(0)
        gmm = BayesianGaussianMixture(n_components=self.n_clusters,
                                      random_state=0,
                                      max_iter=500)
        # Because gmm&#39;s can get quite slow when fitting to large images,
        # we randomly sample a number of voxels equivalent to a 128 x 128 x
        # 3 image to keep runtimes consistent and manageable for large
        # multi-te/ti/dynamic images.
        fit_prop = (128 ** 2 * 3) / np.prod(self.shape)
        fit_mask = np.random.rand(self.pixel_array.size) &lt; fit_prop
        gmm.fit(self.pixel_array.reshape(-1, 1)[fit_mask])
        self.clusters = gmm.predict(self.pixel_array.reshape(-1, 1)).reshape(
            self.shape)
        bg_label = np.argmin(gmm.means_)
        self.noise_mask = self.clusters == bg_label

    def __snr__(self):
        noise = np.std(self.pixel_array[self.noise_mask])
        signal = np.mean(self.pixel_array[~self.noise_mask])
        self.isnr = (signal / noise) * np.sqrt(2 - (np.pi / 2))
        self.isnr_map = (self.pixel_array / noise) * np.sqrt(2 - (np.pi / 2))

    def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;):
        &#34;&#34;&#34;Exports iSNR maps to NIFTI.

        Parameters
        ----------
        output_directory : string, optional
            Path to the folder where the NIFTI files will be saved.
        base_file_name : string, optional
            Filename of the resulting NIFTI. This code appends the extension.
            Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
        &#34;&#34;&#34;
        os.makedirs(output_directory, exist_ok=True)
        base_path = os.path.join(output_directory, base_file_name)

        isnr_nifti = nib.Nifti1Image(self.isnr_map, affine=self.affine)
        nib.save(isnr_nifti, base_path + &#39;_isnr_map.nii.gz&#39;)


class Tsnr:
    &#34;&#34;&#34;
    Attributes
    ----------
    tsnr_map : np.ndarray
        Map of temporal signal to noise ratio.
    &#34;&#34;&#34;

    def __init__(self, pixel_array, affine, mask=None):
        &#34;&#34;&#34;Initialise a temporal signal to noise ratio (tSNR) class instance.

        Parameters
        ----------
        pixel_array : np.ndarray
            A array containing the signal from each voxel with the last
            dimension being repeated dynamics i.e. the array needed to
            generate a tSNR map would have dimensions [x, y, z, d].
        affine : np.ndarray
            A matrix giving the relationship between voxel coordinates and
            world coordinates.
        mask : np.ndarray, optional
            A boolean mask of the voxels to fit. Should be the shape of the
            desired tSNR map rather than the raw data i.e. omit the dynamics
            dimension.
        &#34;&#34;&#34;
        np.seterr(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;)
        self.pixel_array = pixel_array
        self.shape = pixel_array.shape[:-1]
        self.dimensions = len(pixel_array.shape)
        self.n_d = pixel_array.shape[-1]
        self.affine = affine
        # Generate a mask if there isn&#39;t one specified
        if mask is None:
            self.mask = np.ones(self.shape, dtype=bool)
        else:
            self.mask = mask
        # Don&#39;t process any nan values
        self.mask[np.isnan(np.sum(pixel_array, axis=-1))] = False

        self.pixel_array = self.pixel_array * \
            np.repeat(self.mask[..., np.newaxis],
                      self.n_d, axis=-1)

        # Initialise output attributes
        self.tsnr_map = np.zeros(self.shape)
        self.tsnr_map = self.__tsnr__()

    def __tsnr__(self):
        # Regress out linear and quadratic temporal drifts associated with
        # hardware using a GLM of the form Y = X * beta + error
        # as in Hutton C et al. The impact of physiological noise correction
        # on fMRI at 7T. NeuroImage 2011;57:101–112 doi:
        # 10.1016/j.neuroimage.2011.04.018.

        # Vectorise image
        pixel_array_vector = np.reshape(self.pixel_array,
                                        (np.prod(self.shape), self.n_d))
        x = np.vstack([np.ones(self.n_d),
                       np.arange(1, self.n_d + 1),
                       np.arange(1, self.n_d + 1) ** 2]).T
        beta = np.linalg.pinv(x).dot(pixel_array_vector.T)
        pixel_array_vector_detrended = pixel_array_vector.T - \
            x[:, 1:].dot(beta[1:])
        pixel_array_detrended = pixel_array_vector_detrended.T.reshape((
            *self.shape, self.n_d))
        tsnr_map = pixel_array_detrended.mean(axis=-1) / \
            pixel_array_detrended.std(axis=-1)  # Might want to try
        # ddof=1 as per Kevins code...
        tsnr_map[tsnr_map &gt; 1000] = 0
        tsnr_map = np.nan_to_num(tsnr_map)
        return tsnr_map

    def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;):
        &#34;&#34;&#34;Exports tSNR maps to NIFTI.

        Parameters
        ----------
        output_directory : string, optional
            Path to the folder where the NIFTI files will be saved.
        base_file_name : string, optional
            Filename of the resulting NIFTI. This code appends the extension.
            Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
        &#34;&#34;&#34;
        os.makedirs(output_directory, exist_ok=True)
        base_path = os.path.join(output_directory, base_file_name)

        tsnr_nifti = nib.Nifti1Image(self.tsnr_map, affine=self.affine)
        nib.save(tsnr_nifti, base_path + &#39;_tsnr_map.nii.gz&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ukat.qa.snr.Isnr"><code class="flex name class">
<span>class <span class="ident">Isnr</span></span>
<span>(</span><span>pixel_array, affine, noise_mask=None, n_clusters=3)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>isnr</code></strong> :&ensp;<code>float</code></dt>
<dd>Image signal to noise ratio.</dd>
<dt><strong><code>isnr_map</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A map of the image signal to noise ratio.</dd>
<dt><strong><code>noise_mask</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Mask of the ROI used to measure noise levels. Should be voxels
outside the body.</dd>
<dt><strong><code>clusters</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The labels assigned to each voxel during automatic background
segmentation. This can be useful for debugging.</dd>
</dl>
<p>Initialise an image signal to noise ratio (iSNR) class instance.
Parameters</p>
<hr>
<dl>
<dt><strong><code>pixel_array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Array of voxels over which iSNR should be calculated.</dd>
<dt><strong><code>affine</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A matrix giving the relationship between voxel coordinates and
world coordinates.</dd>
<dt><strong><code>noise_mask</code></strong> :&ensp;<code>np.ndarray</code>, optional</dt>
<dd>A binary voxel mask where voxels representing background i.e.
outside the body, are True. If no mask is supplied, one is
estimated using a Bayesian Gaussian mixture model to segment
background voxels.</dd>
<dt><strong><code>n_clusters</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>When using the automatic background segmentation this is the
total number of componenets the image is segmented into. The
component with the lowest mean is assumed to be background.
Default 3.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Isnr:
    &#34;&#34;&#34;
        Attributes
        ----------
        isnr : float
            Image signal to noise ratio.
        isnr_map : np.ndarray
            A map of the image signal to noise ratio.
        noise_mask : np.ndarray
            Mask of the ROI used to measure noise levels. Should be voxels
            outside the body.
        clusters : np.ndarray
            The labels assigned to each voxel during automatic background
            segmentation. This can be useful for debugging.
        &#34;&#34;&#34;

    def __init__(self, pixel_array, affine, noise_mask=None, n_clusters=3):
        &#34;&#34;&#34;Initialise an image signal to noise ratio (iSNR) class instance.
        Parameters
        ----------
        pixel_array : np.ndarray
            Array of voxels over which iSNR should be calculated.
        affine : np.ndarray
            A matrix giving the relationship between voxel coordinates and
            world coordinates.
        noise_mask : np.ndarray, optional
            A binary voxel mask where voxels representing background i.e.
            outside the body, are True. If no mask is supplied, one is
            estimated using a Bayesian Gaussian mixture model to segment
            background voxels.
        n_clusters : int, optional
            When using the automatic background segmentation this is the
            total number of componenets the image is segmented into. The
            component with the lowest mean is assumed to be background.
            Default 3.
        &#34;&#34;&#34;
        self.pixel_array = pixel_array
        self.affine = affine
        self.n_clusters = n_clusters
        self.shape = pixel_array.shape
        self.dimensions = len(pixel_array.shape)

        if noise_mask is None:
            self.__mask_background__()
        else:
            self.noise_mask = noise_mask
            self.clusters = np.nan

        self.isnr = np.nan
        self.isnr_map = np.zeros(self.shape)
        self.__snr__()

    def __mask_background__(self):
        np.random.seed(0)
        gmm = BayesianGaussianMixture(n_components=self.n_clusters,
                                      random_state=0,
                                      max_iter=500)
        # Because gmm&#39;s can get quite slow when fitting to large images,
        # we randomly sample a number of voxels equivalent to a 128 x 128 x
        # 3 image to keep runtimes consistent and manageable for large
        # multi-te/ti/dynamic images.
        fit_prop = (128 ** 2 * 3) / np.prod(self.shape)
        fit_mask = np.random.rand(self.pixel_array.size) &lt; fit_prop
        gmm.fit(self.pixel_array.reshape(-1, 1)[fit_mask])
        self.clusters = gmm.predict(self.pixel_array.reshape(-1, 1)).reshape(
            self.shape)
        bg_label = np.argmin(gmm.means_)
        self.noise_mask = self.clusters == bg_label

    def __snr__(self):
        noise = np.std(self.pixel_array[self.noise_mask])
        signal = np.mean(self.pixel_array[~self.noise_mask])
        self.isnr = (signal / noise) * np.sqrt(2 - (np.pi / 2))
        self.isnr_map = (self.pixel_array / noise) * np.sqrt(2 - (np.pi / 2))

    def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;):
        &#34;&#34;&#34;Exports iSNR maps to NIFTI.

        Parameters
        ----------
        output_directory : string, optional
            Path to the folder where the NIFTI files will be saved.
        base_file_name : string, optional
            Filename of the resulting NIFTI. This code appends the extension.
            Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
        &#34;&#34;&#34;
        os.makedirs(output_directory, exist_ok=True)
        base_path = os.path.join(output_directory, base_file_name)

        isnr_nifti = nib.Nifti1Image(self.isnr_map, affine=self.affine)
        nib.save(isnr_nifti, base_path + &#39;_isnr_map.nii.gz&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ukat.qa.snr.Isnr.to_nifti"><code class="name flex">
<span>def <span class="ident">to_nifti</span></span>(<span>self, output_directory='/home/runner/work/ukat/ukat', base_file_name='Output')</span>
</code></dt>
<dd>
<div class="desc"><p>Exports iSNR maps to NIFTI.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>output_directory</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Path to the folder where the NIFTI files will be saved.</dd>
<dt><strong><code>base_file_name</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Filename of the resulting NIFTI. This code appends the extension.
Eg., base_file_name = 'Output' will result in 'Output.nii.gz'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;):
    &#34;&#34;&#34;Exports iSNR maps to NIFTI.

    Parameters
    ----------
    output_directory : string, optional
        Path to the folder where the NIFTI files will be saved.
    base_file_name : string, optional
        Filename of the resulting NIFTI. This code appends the extension.
        Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
    &#34;&#34;&#34;
    os.makedirs(output_directory, exist_ok=True)
    base_path = os.path.join(output_directory, base_file_name)

    isnr_nifti = nib.Nifti1Image(self.isnr_map, affine=self.affine)
    nib.save(isnr_nifti, base_path + &#39;_isnr_map.nii.gz&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ukat.qa.snr.Tsnr"><code class="flex name class">
<span>class <span class="ident">Tsnr</span></span>
<span>(</span><span>pixel_array, affine, mask=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>tsnr_map</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Map of temporal signal to noise ratio.</dd>
</dl>
<p>Initialise a temporal signal to noise ratio (tSNR) class instance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pixel_array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A array containing the signal from each voxel with the last
dimension being repeated dynamics i.e. the array needed to
generate a tSNR map would have dimensions [x, y, z, d].</dd>
<dt><strong><code>affine</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A matrix giving the relationship between voxel coordinates and
world coordinates.</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>np.ndarray</code>, optional</dt>
<dd>A boolean mask of the voxels to fit. Should be the shape of the
desired tSNR map rather than the raw data i.e. omit the dynamics
dimension.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tsnr:
    &#34;&#34;&#34;
    Attributes
    ----------
    tsnr_map : np.ndarray
        Map of temporal signal to noise ratio.
    &#34;&#34;&#34;

    def __init__(self, pixel_array, affine, mask=None):
        &#34;&#34;&#34;Initialise a temporal signal to noise ratio (tSNR) class instance.

        Parameters
        ----------
        pixel_array : np.ndarray
            A array containing the signal from each voxel with the last
            dimension being repeated dynamics i.e. the array needed to
            generate a tSNR map would have dimensions [x, y, z, d].
        affine : np.ndarray
            A matrix giving the relationship between voxel coordinates and
            world coordinates.
        mask : np.ndarray, optional
            A boolean mask of the voxels to fit. Should be the shape of the
            desired tSNR map rather than the raw data i.e. omit the dynamics
            dimension.
        &#34;&#34;&#34;
        np.seterr(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;)
        self.pixel_array = pixel_array
        self.shape = pixel_array.shape[:-1]
        self.dimensions = len(pixel_array.shape)
        self.n_d = pixel_array.shape[-1]
        self.affine = affine
        # Generate a mask if there isn&#39;t one specified
        if mask is None:
            self.mask = np.ones(self.shape, dtype=bool)
        else:
            self.mask = mask
        # Don&#39;t process any nan values
        self.mask[np.isnan(np.sum(pixel_array, axis=-1))] = False

        self.pixel_array = self.pixel_array * \
            np.repeat(self.mask[..., np.newaxis],
                      self.n_d, axis=-1)

        # Initialise output attributes
        self.tsnr_map = np.zeros(self.shape)
        self.tsnr_map = self.__tsnr__()

    def __tsnr__(self):
        # Regress out linear and quadratic temporal drifts associated with
        # hardware using a GLM of the form Y = X * beta + error
        # as in Hutton C et al. The impact of physiological noise correction
        # on fMRI at 7T. NeuroImage 2011;57:101–112 doi:
        # 10.1016/j.neuroimage.2011.04.018.

        # Vectorise image
        pixel_array_vector = np.reshape(self.pixel_array,
                                        (np.prod(self.shape), self.n_d))
        x = np.vstack([np.ones(self.n_d),
                       np.arange(1, self.n_d + 1),
                       np.arange(1, self.n_d + 1) ** 2]).T
        beta = np.linalg.pinv(x).dot(pixel_array_vector.T)
        pixel_array_vector_detrended = pixel_array_vector.T - \
            x[:, 1:].dot(beta[1:])
        pixel_array_detrended = pixel_array_vector_detrended.T.reshape((
            *self.shape, self.n_d))
        tsnr_map = pixel_array_detrended.mean(axis=-1) / \
            pixel_array_detrended.std(axis=-1)  # Might want to try
        # ddof=1 as per Kevins code...
        tsnr_map[tsnr_map &gt; 1000] = 0
        tsnr_map = np.nan_to_num(tsnr_map)
        return tsnr_map

    def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;):
        &#34;&#34;&#34;Exports tSNR maps to NIFTI.

        Parameters
        ----------
        output_directory : string, optional
            Path to the folder where the NIFTI files will be saved.
        base_file_name : string, optional
            Filename of the resulting NIFTI. This code appends the extension.
            Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
        &#34;&#34;&#34;
        os.makedirs(output_directory, exist_ok=True)
        base_path = os.path.join(output_directory, base_file_name)

        tsnr_nifti = nib.Nifti1Image(self.tsnr_map, affine=self.affine)
        nib.save(tsnr_nifti, base_path + &#39;_tsnr_map.nii.gz&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ukat.qa.snr.Tsnr.to_nifti"><code class="name flex">
<span>def <span class="ident">to_nifti</span></span>(<span>self, output_directory='/home/runner/work/ukat/ukat', base_file_name='Output')</span>
</code></dt>
<dd>
<div class="desc"><p>Exports tSNR maps to NIFTI.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>output_directory</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Path to the folder where the NIFTI files will be saved.</dd>
<dt><strong><code>base_file_name</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Filename of the resulting NIFTI. This code appends the extension.
Eg., base_file_name = 'Output' will result in 'Output.nii.gz'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_nifti(self, output_directory=os.getcwd(), base_file_name=&#39;Output&#39;):
    &#34;&#34;&#34;Exports tSNR maps to NIFTI.

    Parameters
    ----------
    output_directory : string, optional
        Path to the folder where the NIFTI files will be saved.
    base_file_name : string, optional
        Filename of the resulting NIFTI. This code appends the extension.
        Eg., base_file_name = &#39;Output&#39; will result in &#39;Output.nii.gz&#39;.
    &#34;&#34;&#34;
    os.makedirs(output_directory, exist_ok=True)
    base_path = os.path.join(output_directory, base_file_name)

    tsnr_nifti = nib.Nifti1Image(self.tsnr_map, affine=self.affine)
    nib.save(tsnr_nifti, base_path + &#39;_tsnr_map.nii.gz&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ukat.qa" href="index.html">ukat.qa</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ukat.qa.snr.Isnr" href="#ukat.qa.snr.Isnr">Isnr</a></code></h4>
<ul class="">
<li><code><a title="ukat.qa.snr.Isnr.to_nifti" href="#ukat.qa.snr.Isnr.to_nifti">to_nifti</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ukat.qa.snr.Tsnr" href="#ukat.qa.snr.Tsnr">Tsnr</a></code></h4>
<ul class="">
<li><code><a title="ukat.qa.snr.Tsnr.to_nifti" href="#ukat.qa.snr.Tsnr.to_nifti">to_nifti</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>